// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/NpoolPlatform/inspire-manager/pkg/db/ent/archivementdetail"
	"github.com/NpoolPlatform/inspire-manager/pkg/db/ent/archivementgeneral"
	"github.com/NpoolPlatform/inspire-manager/pkg/db/ent/couponallocated"
	"github.com/NpoolPlatform/inspire-manager/pkg/db/ent/coupondiscount"
	"github.com/NpoolPlatform/inspire-manager/pkg/db/ent/couponfixamount"
	"github.com/NpoolPlatform/inspire-manager/pkg/db/ent/couponspecialoffer"
	"github.com/NpoolPlatform/inspire-manager/pkg/db/ent/goodorderpercent"
	"github.com/NpoolPlatform/inspire-manager/pkg/db/ent/goodordervaluepercent"
	"github.com/NpoolPlatform/inspire-manager/pkg/db/ent/invitationcode"
	"github.com/NpoolPlatform/inspire-manager/pkg/db/ent/predicate"
	"github.com/NpoolPlatform/inspire-manager/pkg/db/ent/registration"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArchivementDetail     = "ArchivementDetail"
	TypeArchivementGeneral    = "ArchivementGeneral"
	TypeCouponAllocated       = "CouponAllocated"
	TypeCouponDiscount        = "CouponDiscount"
	TypeCouponFixAmount       = "CouponFixAmount"
	TypeCouponSpecialOffer    = "CouponSpecialOffer"
	TypeGoodOrderPercent      = "GoodOrderPercent"
	TypeGoodOrderValuePercent = "GoodOrderValuePercent"
	TypeInvitationCode        = "InvitationCode"
	TypeRegistration          = "Registration"
)

// ArchivementDetailMutation represents an operation that mutates the ArchivementDetail nodes in the graph.
type ArchivementDetailMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *uint32
	addcreated_at             *int32
	updated_at                *uint32
	addupdated_at             *int32
	deleted_at                *uint32
	adddeleted_at             *int32
	app_id                    *uuid.UUID
	user_id                   *uuid.UUID
	direct_contributor_id     *uuid.UUID
	good_id                   *uuid.UUID
	order_id                  *uuid.UUID
	self_order                *bool
	payment_id                *uuid.UUID
	coin_type_id              *uuid.UUID
	payment_coin_type_id      *uuid.UUID
	payment_coin_usd_currency *decimal.Decimal
	units                     *uint32
	addunits                  *int32
	amount                    *decimal.Decimal
	usd_amount                *decimal.Decimal
	commission                *decimal.Decimal
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*ArchivementDetail, error)
	predicates                []predicate.ArchivementDetail
}

var _ ent.Mutation = (*ArchivementDetailMutation)(nil)

// archivementdetailOption allows management of the mutation configuration using functional options.
type archivementdetailOption func(*ArchivementDetailMutation)

// newArchivementDetailMutation creates new mutation for the ArchivementDetail entity.
func newArchivementDetailMutation(c config, op Op, opts ...archivementdetailOption) *ArchivementDetailMutation {
	m := &ArchivementDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeArchivementDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArchivementDetailID sets the ID field of the mutation.
func withArchivementDetailID(id uuid.UUID) archivementdetailOption {
	return func(m *ArchivementDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *ArchivementDetail
		)
		m.oldValue = func(ctx context.Context) (*ArchivementDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArchivementDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArchivementDetail sets the old ArchivementDetail of the mutation.
func withArchivementDetail(node *ArchivementDetail) archivementdetailOption {
	return func(m *ArchivementDetailMutation) {
		m.oldValue = func(context.Context) (*ArchivementDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArchivementDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArchivementDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ArchivementDetail entities.
func (m *ArchivementDetailMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArchivementDetailMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArchivementDetailMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArchivementDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ArchivementDetailMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArchivementDetailMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *ArchivementDetailMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ArchivementDetailMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArchivementDetailMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArchivementDetailMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArchivementDetailMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *ArchivementDetailMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ArchivementDetailMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArchivementDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ArchivementDetailMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ArchivementDetailMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *ArchivementDetailMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ArchivementDetailMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ArchivementDetailMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *ArchivementDetailMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *ArchivementDetailMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *ArchivementDetailMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[archivementdetail.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *ArchivementDetailMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[archivementdetail.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *ArchivementDetailMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, archivementdetail.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *ArchivementDetailMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ArchivementDetailMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ArchivementDetailMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[archivementdetail.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ArchivementDetailMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[archivementdetail.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ArchivementDetailMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, archivementdetail.FieldUserID)
}

// SetDirectContributorID sets the "direct_contributor_id" field.
func (m *ArchivementDetailMutation) SetDirectContributorID(u uuid.UUID) {
	m.direct_contributor_id = &u
}

// DirectContributorID returns the value of the "direct_contributor_id" field in the mutation.
func (m *ArchivementDetailMutation) DirectContributorID() (r uuid.UUID, exists bool) {
	v := m.direct_contributor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectContributorID returns the old "direct_contributor_id" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldDirectContributorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectContributorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectContributorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectContributorID: %w", err)
	}
	return oldValue.DirectContributorID, nil
}

// ClearDirectContributorID clears the value of the "direct_contributor_id" field.
func (m *ArchivementDetailMutation) ClearDirectContributorID() {
	m.direct_contributor_id = nil
	m.clearedFields[archivementdetail.FieldDirectContributorID] = struct{}{}
}

// DirectContributorIDCleared returns if the "direct_contributor_id" field was cleared in this mutation.
func (m *ArchivementDetailMutation) DirectContributorIDCleared() bool {
	_, ok := m.clearedFields[archivementdetail.FieldDirectContributorID]
	return ok
}

// ResetDirectContributorID resets all changes to the "direct_contributor_id" field.
func (m *ArchivementDetailMutation) ResetDirectContributorID() {
	m.direct_contributor_id = nil
	delete(m.clearedFields, archivementdetail.FieldDirectContributorID)
}

// SetGoodID sets the "good_id" field.
func (m *ArchivementDetailMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *ArchivementDetailMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *ArchivementDetailMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[archivementdetail.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *ArchivementDetailMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[archivementdetail.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *ArchivementDetailMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, archivementdetail.FieldGoodID)
}

// SetOrderID sets the "order_id" field.
func (m *ArchivementDetailMutation) SetOrderID(u uuid.UUID) {
	m.order_id = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *ArchivementDetailMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *ArchivementDetailMutation) ClearOrderID() {
	m.order_id = nil
	m.clearedFields[archivementdetail.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *ArchivementDetailMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[archivementdetail.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *ArchivementDetailMutation) ResetOrderID() {
	m.order_id = nil
	delete(m.clearedFields, archivementdetail.FieldOrderID)
}

// SetSelfOrder sets the "self_order" field.
func (m *ArchivementDetailMutation) SetSelfOrder(b bool) {
	m.self_order = &b
}

// SelfOrder returns the value of the "self_order" field in the mutation.
func (m *ArchivementDetailMutation) SelfOrder() (r bool, exists bool) {
	v := m.self_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfOrder returns the old "self_order" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldSelfOrder(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfOrder: %w", err)
	}
	return oldValue.SelfOrder, nil
}

// ClearSelfOrder clears the value of the "self_order" field.
func (m *ArchivementDetailMutation) ClearSelfOrder() {
	m.self_order = nil
	m.clearedFields[archivementdetail.FieldSelfOrder] = struct{}{}
}

// SelfOrderCleared returns if the "self_order" field was cleared in this mutation.
func (m *ArchivementDetailMutation) SelfOrderCleared() bool {
	_, ok := m.clearedFields[archivementdetail.FieldSelfOrder]
	return ok
}

// ResetSelfOrder resets all changes to the "self_order" field.
func (m *ArchivementDetailMutation) ResetSelfOrder() {
	m.self_order = nil
	delete(m.clearedFields, archivementdetail.FieldSelfOrder)
}

// SetPaymentID sets the "payment_id" field.
func (m *ArchivementDetailMutation) SetPaymentID(u uuid.UUID) {
	m.payment_id = &u
}

// PaymentID returns the value of the "payment_id" field in the mutation.
func (m *ArchivementDetailMutation) PaymentID() (r uuid.UUID, exists bool) {
	v := m.payment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentID returns the old "payment_id" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldPaymentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentID: %w", err)
	}
	return oldValue.PaymentID, nil
}

// ClearPaymentID clears the value of the "payment_id" field.
func (m *ArchivementDetailMutation) ClearPaymentID() {
	m.payment_id = nil
	m.clearedFields[archivementdetail.FieldPaymentID] = struct{}{}
}

// PaymentIDCleared returns if the "payment_id" field was cleared in this mutation.
func (m *ArchivementDetailMutation) PaymentIDCleared() bool {
	_, ok := m.clearedFields[archivementdetail.FieldPaymentID]
	return ok
}

// ResetPaymentID resets all changes to the "payment_id" field.
func (m *ArchivementDetailMutation) ResetPaymentID() {
	m.payment_id = nil
	delete(m.clearedFields, archivementdetail.FieldPaymentID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *ArchivementDetailMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *ArchivementDetailMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *ArchivementDetailMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[archivementdetail.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *ArchivementDetailMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[archivementdetail.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *ArchivementDetailMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, archivementdetail.FieldCoinTypeID)
}

// SetPaymentCoinTypeID sets the "payment_coin_type_id" field.
func (m *ArchivementDetailMutation) SetPaymentCoinTypeID(u uuid.UUID) {
	m.payment_coin_type_id = &u
}

// PaymentCoinTypeID returns the value of the "payment_coin_type_id" field in the mutation.
func (m *ArchivementDetailMutation) PaymentCoinTypeID() (r uuid.UUID, exists bool) {
	v := m.payment_coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentCoinTypeID returns the old "payment_coin_type_id" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldPaymentCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentCoinTypeID: %w", err)
	}
	return oldValue.PaymentCoinTypeID, nil
}

// ClearPaymentCoinTypeID clears the value of the "payment_coin_type_id" field.
func (m *ArchivementDetailMutation) ClearPaymentCoinTypeID() {
	m.payment_coin_type_id = nil
	m.clearedFields[archivementdetail.FieldPaymentCoinTypeID] = struct{}{}
}

// PaymentCoinTypeIDCleared returns if the "payment_coin_type_id" field was cleared in this mutation.
func (m *ArchivementDetailMutation) PaymentCoinTypeIDCleared() bool {
	_, ok := m.clearedFields[archivementdetail.FieldPaymentCoinTypeID]
	return ok
}

// ResetPaymentCoinTypeID resets all changes to the "payment_coin_type_id" field.
func (m *ArchivementDetailMutation) ResetPaymentCoinTypeID() {
	m.payment_coin_type_id = nil
	delete(m.clearedFields, archivementdetail.FieldPaymentCoinTypeID)
}

// SetPaymentCoinUsdCurrency sets the "payment_coin_usd_currency" field.
func (m *ArchivementDetailMutation) SetPaymentCoinUsdCurrency(d decimal.Decimal) {
	m.payment_coin_usd_currency = &d
}

// PaymentCoinUsdCurrency returns the value of the "payment_coin_usd_currency" field in the mutation.
func (m *ArchivementDetailMutation) PaymentCoinUsdCurrency() (r decimal.Decimal, exists bool) {
	v := m.payment_coin_usd_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentCoinUsdCurrency returns the old "payment_coin_usd_currency" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldPaymentCoinUsdCurrency(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentCoinUsdCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentCoinUsdCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentCoinUsdCurrency: %w", err)
	}
	return oldValue.PaymentCoinUsdCurrency, nil
}

// ClearPaymentCoinUsdCurrency clears the value of the "payment_coin_usd_currency" field.
func (m *ArchivementDetailMutation) ClearPaymentCoinUsdCurrency() {
	m.payment_coin_usd_currency = nil
	m.clearedFields[archivementdetail.FieldPaymentCoinUsdCurrency] = struct{}{}
}

// PaymentCoinUsdCurrencyCleared returns if the "payment_coin_usd_currency" field was cleared in this mutation.
func (m *ArchivementDetailMutation) PaymentCoinUsdCurrencyCleared() bool {
	_, ok := m.clearedFields[archivementdetail.FieldPaymentCoinUsdCurrency]
	return ok
}

// ResetPaymentCoinUsdCurrency resets all changes to the "payment_coin_usd_currency" field.
func (m *ArchivementDetailMutation) ResetPaymentCoinUsdCurrency() {
	m.payment_coin_usd_currency = nil
	delete(m.clearedFields, archivementdetail.FieldPaymentCoinUsdCurrency)
}

// SetUnits sets the "units" field.
func (m *ArchivementDetailMutation) SetUnits(u uint32) {
	m.units = &u
	m.addunits = nil
}

// Units returns the value of the "units" field in the mutation.
func (m *ArchivementDetailMutation) Units() (r uint32, exists bool) {
	v := m.units
	if v == nil {
		return
	}
	return *v, true
}

// OldUnits returns the old "units" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldUnits(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnits: %w", err)
	}
	return oldValue.Units, nil
}

// AddUnits adds u to the "units" field.
func (m *ArchivementDetailMutation) AddUnits(u int32) {
	if m.addunits != nil {
		*m.addunits += u
	} else {
		m.addunits = &u
	}
}

// AddedUnits returns the value that was added to the "units" field in this mutation.
func (m *ArchivementDetailMutation) AddedUnits() (r int32, exists bool) {
	v := m.addunits
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnits clears the value of the "units" field.
func (m *ArchivementDetailMutation) ClearUnits() {
	m.units = nil
	m.addunits = nil
	m.clearedFields[archivementdetail.FieldUnits] = struct{}{}
}

// UnitsCleared returns if the "units" field was cleared in this mutation.
func (m *ArchivementDetailMutation) UnitsCleared() bool {
	_, ok := m.clearedFields[archivementdetail.FieldUnits]
	return ok
}

// ResetUnits resets all changes to the "units" field.
func (m *ArchivementDetailMutation) ResetUnits() {
	m.units = nil
	m.addunits = nil
	delete(m.clearedFields, archivementdetail.FieldUnits)
}

// SetAmount sets the "amount" field.
func (m *ArchivementDetailMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *ArchivementDetailMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ClearAmount clears the value of the "amount" field.
func (m *ArchivementDetailMutation) ClearAmount() {
	m.amount = nil
	m.clearedFields[archivementdetail.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *ArchivementDetailMutation) AmountCleared() bool {
	_, ok := m.clearedFields[archivementdetail.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *ArchivementDetailMutation) ResetAmount() {
	m.amount = nil
	delete(m.clearedFields, archivementdetail.FieldAmount)
}

// SetUsdAmount sets the "usd_amount" field.
func (m *ArchivementDetailMutation) SetUsdAmount(d decimal.Decimal) {
	m.usd_amount = &d
}

// UsdAmount returns the value of the "usd_amount" field in the mutation.
func (m *ArchivementDetailMutation) UsdAmount() (r decimal.Decimal, exists bool) {
	v := m.usd_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldUsdAmount returns the old "usd_amount" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldUsdAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsdAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsdAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsdAmount: %w", err)
	}
	return oldValue.UsdAmount, nil
}

// ClearUsdAmount clears the value of the "usd_amount" field.
func (m *ArchivementDetailMutation) ClearUsdAmount() {
	m.usd_amount = nil
	m.clearedFields[archivementdetail.FieldUsdAmount] = struct{}{}
}

// UsdAmountCleared returns if the "usd_amount" field was cleared in this mutation.
func (m *ArchivementDetailMutation) UsdAmountCleared() bool {
	_, ok := m.clearedFields[archivementdetail.FieldUsdAmount]
	return ok
}

// ResetUsdAmount resets all changes to the "usd_amount" field.
func (m *ArchivementDetailMutation) ResetUsdAmount() {
	m.usd_amount = nil
	delete(m.clearedFields, archivementdetail.FieldUsdAmount)
}

// SetCommission sets the "commission" field.
func (m *ArchivementDetailMutation) SetCommission(d decimal.Decimal) {
	m.commission = &d
}

// Commission returns the value of the "commission" field in the mutation.
func (m *ArchivementDetailMutation) Commission() (r decimal.Decimal, exists bool) {
	v := m.commission
	if v == nil {
		return
	}
	return *v, true
}

// OldCommission returns the old "commission" field's value of the ArchivementDetail entity.
// If the ArchivementDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementDetailMutation) OldCommission(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommission: %w", err)
	}
	return oldValue.Commission, nil
}

// ClearCommission clears the value of the "commission" field.
func (m *ArchivementDetailMutation) ClearCommission() {
	m.commission = nil
	m.clearedFields[archivementdetail.FieldCommission] = struct{}{}
}

// CommissionCleared returns if the "commission" field was cleared in this mutation.
func (m *ArchivementDetailMutation) CommissionCleared() bool {
	_, ok := m.clearedFields[archivementdetail.FieldCommission]
	return ok
}

// ResetCommission resets all changes to the "commission" field.
func (m *ArchivementDetailMutation) ResetCommission() {
	m.commission = nil
	delete(m.clearedFields, archivementdetail.FieldCommission)
}

// Where appends a list predicates to the ArchivementDetailMutation builder.
func (m *ArchivementDetailMutation) Where(ps ...predicate.ArchivementDetail) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ArchivementDetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ArchivementDetail).
func (m *ArchivementDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArchivementDetailMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, archivementdetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, archivementdetail.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, archivementdetail.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, archivementdetail.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, archivementdetail.FieldUserID)
	}
	if m.direct_contributor_id != nil {
		fields = append(fields, archivementdetail.FieldDirectContributorID)
	}
	if m.good_id != nil {
		fields = append(fields, archivementdetail.FieldGoodID)
	}
	if m.order_id != nil {
		fields = append(fields, archivementdetail.FieldOrderID)
	}
	if m.self_order != nil {
		fields = append(fields, archivementdetail.FieldSelfOrder)
	}
	if m.payment_id != nil {
		fields = append(fields, archivementdetail.FieldPaymentID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, archivementdetail.FieldCoinTypeID)
	}
	if m.payment_coin_type_id != nil {
		fields = append(fields, archivementdetail.FieldPaymentCoinTypeID)
	}
	if m.payment_coin_usd_currency != nil {
		fields = append(fields, archivementdetail.FieldPaymentCoinUsdCurrency)
	}
	if m.units != nil {
		fields = append(fields, archivementdetail.FieldUnits)
	}
	if m.amount != nil {
		fields = append(fields, archivementdetail.FieldAmount)
	}
	if m.usd_amount != nil {
		fields = append(fields, archivementdetail.FieldUsdAmount)
	}
	if m.commission != nil {
		fields = append(fields, archivementdetail.FieldCommission)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArchivementDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case archivementdetail.FieldCreatedAt:
		return m.CreatedAt()
	case archivementdetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case archivementdetail.FieldDeletedAt:
		return m.DeletedAt()
	case archivementdetail.FieldAppID:
		return m.AppID()
	case archivementdetail.FieldUserID:
		return m.UserID()
	case archivementdetail.FieldDirectContributorID:
		return m.DirectContributorID()
	case archivementdetail.FieldGoodID:
		return m.GoodID()
	case archivementdetail.FieldOrderID:
		return m.OrderID()
	case archivementdetail.FieldSelfOrder:
		return m.SelfOrder()
	case archivementdetail.FieldPaymentID:
		return m.PaymentID()
	case archivementdetail.FieldCoinTypeID:
		return m.CoinTypeID()
	case archivementdetail.FieldPaymentCoinTypeID:
		return m.PaymentCoinTypeID()
	case archivementdetail.FieldPaymentCoinUsdCurrency:
		return m.PaymentCoinUsdCurrency()
	case archivementdetail.FieldUnits:
		return m.Units()
	case archivementdetail.FieldAmount:
		return m.Amount()
	case archivementdetail.FieldUsdAmount:
		return m.UsdAmount()
	case archivementdetail.FieldCommission:
		return m.Commission()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArchivementDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case archivementdetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case archivementdetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case archivementdetail.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case archivementdetail.FieldAppID:
		return m.OldAppID(ctx)
	case archivementdetail.FieldUserID:
		return m.OldUserID(ctx)
	case archivementdetail.FieldDirectContributorID:
		return m.OldDirectContributorID(ctx)
	case archivementdetail.FieldGoodID:
		return m.OldGoodID(ctx)
	case archivementdetail.FieldOrderID:
		return m.OldOrderID(ctx)
	case archivementdetail.FieldSelfOrder:
		return m.OldSelfOrder(ctx)
	case archivementdetail.FieldPaymentID:
		return m.OldPaymentID(ctx)
	case archivementdetail.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case archivementdetail.FieldPaymentCoinTypeID:
		return m.OldPaymentCoinTypeID(ctx)
	case archivementdetail.FieldPaymentCoinUsdCurrency:
		return m.OldPaymentCoinUsdCurrency(ctx)
	case archivementdetail.FieldUnits:
		return m.OldUnits(ctx)
	case archivementdetail.FieldAmount:
		return m.OldAmount(ctx)
	case archivementdetail.FieldUsdAmount:
		return m.OldUsdAmount(ctx)
	case archivementdetail.FieldCommission:
		return m.OldCommission(ctx)
	}
	return nil, fmt.Errorf("unknown ArchivementDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArchivementDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case archivementdetail.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case archivementdetail.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case archivementdetail.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case archivementdetail.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case archivementdetail.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case archivementdetail.FieldDirectContributorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectContributorID(v)
		return nil
	case archivementdetail.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case archivementdetail.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case archivementdetail.FieldSelfOrder:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfOrder(v)
		return nil
	case archivementdetail.FieldPaymentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentID(v)
		return nil
	case archivementdetail.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case archivementdetail.FieldPaymentCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentCoinTypeID(v)
		return nil
	case archivementdetail.FieldPaymentCoinUsdCurrency:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentCoinUsdCurrency(v)
		return nil
	case archivementdetail.FieldUnits:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnits(v)
		return nil
	case archivementdetail.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case archivementdetail.FieldUsdAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsdAmount(v)
		return nil
	case archivementdetail.FieldCommission:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommission(v)
		return nil
	}
	return fmt.Errorf("unknown ArchivementDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArchivementDetailMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, archivementdetail.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, archivementdetail.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, archivementdetail.FieldDeletedAt)
	}
	if m.addunits != nil {
		fields = append(fields, archivementdetail.FieldUnits)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArchivementDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case archivementdetail.FieldCreatedAt:
		return m.AddedCreatedAt()
	case archivementdetail.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case archivementdetail.FieldDeletedAt:
		return m.AddedDeletedAt()
	case archivementdetail.FieldUnits:
		return m.AddedUnits()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArchivementDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case archivementdetail.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case archivementdetail.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case archivementdetail.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case archivementdetail.FieldUnits:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnits(v)
		return nil
	}
	return fmt.Errorf("unknown ArchivementDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArchivementDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(archivementdetail.FieldAppID) {
		fields = append(fields, archivementdetail.FieldAppID)
	}
	if m.FieldCleared(archivementdetail.FieldUserID) {
		fields = append(fields, archivementdetail.FieldUserID)
	}
	if m.FieldCleared(archivementdetail.FieldDirectContributorID) {
		fields = append(fields, archivementdetail.FieldDirectContributorID)
	}
	if m.FieldCleared(archivementdetail.FieldGoodID) {
		fields = append(fields, archivementdetail.FieldGoodID)
	}
	if m.FieldCleared(archivementdetail.FieldOrderID) {
		fields = append(fields, archivementdetail.FieldOrderID)
	}
	if m.FieldCleared(archivementdetail.FieldSelfOrder) {
		fields = append(fields, archivementdetail.FieldSelfOrder)
	}
	if m.FieldCleared(archivementdetail.FieldPaymentID) {
		fields = append(fields, archivementdetail.FieldPaymentID)
	}
	if m.FieldCleared(archivementdetail.FieldCoinTypeID) {
		fields = append(fields, archivementdetail.FieldCoinTypeID)
	}
	if m.FieldCleared(archivementdetail.FieldPaymentCoinTypeID) {
		fields = append(fields, archivementdetail.FieldPaymentCoinTypeID)
	}
	if m.FieldCleared(archivementdetail.FieldPaymentCoinUsdCurrency) {
		fields = append(fields, archivementdetail.FieldPaymentCoinUsdCurrency)
	}
	if m.FieldCleared(archivementdetail.FieldUnits) {
		fields = append(fields, archivementdetail.FieldUnits)
	}
	if m.FieldCleared(archivementdetail.FieldAmount) {
		fields = append(fields, archivementdetail.FieldAmount)
	}
	if m.FieldCleared(archivementdetail.FieldUsdAmount) {
		fields = append(fields, archivementdetail.FieldUsdAmount)
	}
	if m.FieldCleared(archivementdetail.FieldCommission) {
		fields = append(fields, archivementdetail.FieldCommission)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArchivementDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArchivementDetailMutation) ClearField(name string) error {
	switch name {
	case archivementdetail.FieldAppID:
		m.ClearAppID()
		return nil
	case archivementdetail.FieldUserID:
		m.ClearUserID()
		return nil
	case archivementdetail.FieldDirectContributorID:
		m.ClearDirectContributorID()
		return nil
	case archivementdetail.FieldGoodID:
		m.ClearGoodID()
		return nil
	case archivementdetail.FieldOrderID:
		m.ClearOrderID()
		return nil
	case archivementdetail.FieldSelfOrder:
		m.ClearSelfOrder()
		return nil
	case archivementdetail.FieldPaymentID:
		m.ClearPaymentID()
		return nil
	case archivementdetail.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case archivementdetail.FieldPaymentCoinTypeID:
		m.ClearPaymentCoinTypeID()
		return nil
	case archivementdetail.FieldPaymentCoinUsdCurrency:
		m.ClearPaymentCoinUsdCurrency()
		return nil
	case archivementdetail.FieldUnits:
		m.ClearUnits()
		return nil
	case archivementdetail.FieldAmount:
		m.ClearAmount()
		return nil
	case archivementdetail.FieldUsdAmount:
		m.ClearUsdAmount()
		return nil
	case archivementdetail.FieldCommission:
		m.ClearCommission()
		return nil
	}
	return fmt.Errorf("unknown ArchivementDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArchivementDetailMutation) ResetField(name string) error {
	switch name {
	case archivementdetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case archivementdetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case archivementdetail.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case archivementdetail.FieldAppID:
		m.ResetAppID()
		return nil
	case archivementdetail.FieldUserID:
		m.ResetUserID()
		return nil
	case archivementdetail.FieldDirectContributorID:
		m.ResetDirectContributorID()
		return nil
	case archivementdetail.FieldGoodID:
		m.ResetGoodID()
		return nil
	case archivementdetail.FieldOrderID:
		m.ResetOrderID()
		return nil
	case archivementdetail.FieldSelfOrder:
		m.ResetSelfOrder()
		return nil
	case archivementdetail.FieldPaymentID:
		m.ResetPaymentID()
		return nil
	case archivementdetail.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case archivementdetail.FieldPaymentCoinTypeID:
		m.ResetPaymentCoinTypeID()
		return nil
	case archivementdetail.FieldPaymentCoinUsdCurrency:
		m.ResetPaymentCoinUsdCurrency()
		return nil
	case archivementdetail.FieldUnits:
		m.ResetUnits()
		return nil
	case archivementdetail.FieldAmount:
		m.ResetAmount()
		return nil
	case archivementdetail.FieldUsdAmount:
		m.ResetUsdAmount()
		return nil
	case archivementdetail.FieldCommission:
		m.ResetCommission()
		return nil
	}
	return fmt.Errorf("unknown ArchivementDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArchivementDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArchivementDetailMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArchivementDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArchivementDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArchivementDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArchivementDetailMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArchivementDetailMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ArchivementDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArchivementDetailMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ArchivementDetail edge %s", name)
}

// ArchivementGeneralMutation represents an operation that mutates the ArchivementGeneral nodes in the graph.
type ArchivementGeneralMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	app_id           *uuid.UUID
	user_id          *uuid.UUID
	good_id          *uuid.UUID
	coin_type_id     *uuid.UUID
	total_units      *uint32
	addtotal_units   *int32
	self_units       *uint32
	addself_units    *int32
	total_amount     *decimal.Decimal
	self_amount      *decimal.Decimal
	total_commission *decimal.Decimal
	self_commission  *decimal.Decimal
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*ArchivementGeneral, error)
	predicates       []predicate.ArchivementGeneral
}

var _ ent.Mutation = (*ArchivementGeneralMutation)(nil)

// archivementgeneralOption allows management of the mutation configuration using functional options.
type archivementgeneralOption func(*ArchivementGeneralMutation)

// newArchivementGeneralMutation creates new mutation for the ArchivementGeneral entity.
func newArchivementGeneralMutation(c config, op Op, opts ...archivementgeneralOption) *ArchivementGeneralMutation {
	m := &ArchivementGeneralMutation{
		config:        c,
		op:            op,
		typ:           TypeArchivementGeneral,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArchivementGeneralID sets the ID field of the mutation.
func withArchivementGeneralID(id uuid.UUID) archivementgeneralOption {
	return func(m *ArchivementGeneralMutation) {
		var (
			err   error
			once  sync.Once
			value *ArchivementGeneral
		)
		m.oldValue = func(ctx context.Context) (*ArchivementGeneral, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArchivementGeneral.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArchivementGeneral sets the old ArchivementGeneral of the mutation.
func withArchivementGeneral(node *ArchivementGeneral) archivementgeneralOption {
	return func(m *ArchivementGeneralMutation) {
		m.oldValue = func(context.Context) (*ArchivementGeneral, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArchivementGeneralMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArchivementGeneralMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ArchivementGeneral entities.
func (m *ArchivementGeneralMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArchivementGeneralMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArchivementGeneralMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArchivementGeneral.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ArchivementGeneralMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArchivementGeneralMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArchivementGeneral entity.
// If the ArchivementGeneral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementGeneralMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *ArchivementGeneralMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ArchivementGeneralMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArchivementGeneralMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArchivementGeneralMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArchivementGeneralMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArchivementGeneral entity.
// If the ArchivementGeneral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementGeneralMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *ArchivementGeneralMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ArchivementGeneralMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArchivementGeneralMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ArchivementGeneralMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ArchivementGeneralMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ArchivementGeneral entity.
// If the ArchivementGeneral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementGeneralMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *ArchivementGeneralMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ArchivementGeneralMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ArchivementGeneralMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *ArchivementGeneralMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *ArchivementGeneralMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the ArchivementGeneral entity.
// If the ArchivementGeneral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementGeneralMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *ArchivementGeneralMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[archivementgeneral.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *ArchivementGeneralMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[archivementgeneral.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *ArchivementGeneralMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, archivementgeneral.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *ArchivementGeneralMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ArchivementGeneralMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ArchivementGeneral entity.
// If the ArchivementGeneral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementGeneralMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ArchivementGeneralMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[archivementgeneral.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ArchivementGeneralMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[archivementgeneral.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ArchivementGeneralMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, archivementgeneral.FieldUserID)
}

// SetGoodID sets the "good_id" field.
func (m *ArchivementGeneralMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *ArchivementGeneralMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the ArchivementGeneral entity.
// If the ArchivementGeneral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementGeneralMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *ArchivementGeneralMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[archivementgeneral.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *ArchivementGeneralMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[archivementgeneral.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *ArchivementGeneralMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, archivementgeneral.FieldGoodID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *ArchivementGeneralMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *ArchivementGeneralMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the ArchivementGeneral entity.
// If the ArchivementGeneral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementGeneralMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *ArchivementGeneralMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[archivementgeneral.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *ArchivementGeneralMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[archivementgeneral.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *ArchivementGeneralMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, archivementgeneral.FieldCoinTypeID)
}

// SetTotalUnits sets the "total_units" field.
func (m *ArchivementGeneralMutation) SetTotalUnits(u uint32) {
	m.total_units = &u
	m.addtotal_units = nil
}

// TotalUnits returns the value of the "total_units" field in the mutation.
func (m *ArchivementGeneralMutation) TotalUnits() (r uint32, exists bool) {
	v := m.total_units
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalUnits returns the old "total_units" field's value of the ArchivementGeneral entity.
// If the ArchivementGeneral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementGeneralMutation) OldTotalUnits(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalUnits: %w", err)
	}
	return oldValue.TotalUnits, nil
}

// AddTotalUnits adds u to the "total_units" field.
func (m *ArchivementGeneralMutation) AddTotalUnits(u int32) {
	if m.addtotal_units != nil {
		*m.addtotal_units += u
	} else {
		m.addtotal_units = &u
	}
}

// AddedTotalUnits returns the value that was added to the "total_units" field in this mutation.
func (m *ArchivementGeneralMutation) AddedTotalUnits() (r int32, exists bool) {
	v := m.addtotal_units
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalUnits clears the value of the "total_units" field.
func (m *ArchivementGeneralMutation) ClearTotalUnits() {
	m.total_units = nil
	m.addtotal_units = nil
	m.clearedFields[archivementgeneral.FieldTotalUnits] = struct{}{}
}

// TotalUnitsCleared returns if the "total_units" field was cleared in this mutation.
func (m *ArchivementGeneralMutation) TotalUnitsCleared() bool {
	_, ok := m.clearedFields[archivementgeneral.FieldTotalUnits]
	return ok
}

// ResetTotalUnits resets all changes to the "total_units" field.
func (m *ArchivementGeneralMutation) ResetTotalUnits() {
	m.total_units = nil
	m.addtotal_units = nil
	delete(m.clearedFields, archivementgeneral.FieldTotalUnits)
}

// SetSelfUnits sets the "self_units" field.
func (m *ArchivementGeneralMutation) SetSelfUnits(u uint32) {
	m.self_units = &u
	m.addself_units = nil
}

// SelfUnits returns the value of the "self_units" field in the mutation.
func (m *ArchivementGeneralMutation) SelfUnits() (r uint32, exists bool) {
	v := m.self_units
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfUnits returns the old "self_units" field's value of the ArchivementGeneral entity.
// If the ArchivementGeneral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementGeneralMutation) OldSelfUnits(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfUnits: %w", err)
	}
	return oldValue.SelfUnits, nil
}

// AddSelfUnits adds u to the "self_units" field.
func (m *ArchivementGeneralMutation) AddSelfUnits(u int32) {
	if m.addself_units != nil {
		*m.addself_units += u
	} else {
		m.addself_units = &u
	}
}

// AddedSelfUnits returns the value that was added to the "self_units" field in this mutation.
func (m *ArchivementGeneralMutation) AddedSelfUnits() (r int32, exists bool) {
	v := m.addself_units
	if v == nil {
		return
	}
	return *v, true
}

// ClearSelfUnits clears the value of the "self_units" field.
func (m *ArchivementGeneralMutation) ClearSelfUnits() {
	m.self_units = nil
	m.addself_units = nil
	m.clearedFields[archivementgeneral.FieldSelfUnits] = struct{}{}
}

// SelfUnitsCleared returns if the "self_units" field was cleared in this mutation.
func (m *ArchivementGeneralMutation) SelfUnitsCleared() bool {
	_, ok := m.clearedFields[archivementgeneral.FieldSelfUnits]
	return ok
}

// ResetSelfUnits resets all changes to the "self_units" field.
func (m *ArchivementGeneralMutation) ResetSelfUnits() {
	m.self_units = nil
	m.addself_units = nil
	delete(m.clearedFields, archivementgeneral.FieldSelfUnits)
}

// SetTotalAmount sets the "total_amount" field.
func (m *ArchivementGeneralMutation) SetTotalAmount(d decimal.Decimal) {
	m.total_amount = &d
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *ArchivementGeneralMutation) TotalAmount() (r decimal.Decimal, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the ArchivementGeneral entity.
// If the ArchivementGeneral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementGeneralMutation) OldTotalAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// ClearTotalAmount clears the value of the "total_amount" field.
func (m *ArchivementGeneralMutation) ClearTotalAmount() {
	m.total_amount = nil
	m.clearedFields[archivementgeneral.FieldTotalAmount] = struct{}{}
}

// TotalAmountCleared returns if the "total_amount" field was cleared in this mutation.
func (m *ArchivementGeneralMutation) TotalAmountCleared() bool {
	_, ok := m.clearedFields[archivementgeneral.FieldTotalAmount]
	return ok
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *ArchivementGeneralMutation) ResetTotalAmount() {
	m.total_amount = nil
	delete(m.clearedFields, archivementgeneral.FieldTotalAmount)
}

// SetSelfAmount sets the "self_amount" field.
func (m *ArchivementGeneralMutation) SetSelfAmount(d decimal.Decimal) {
	m.self_amount = &d
}

// SelfAmount returns the value of the "self_amount" field in the mutation.
func (m *ArchivementGeneralMutation) SelfAmount() (r decimal.Decimal, exists bool) {
	v := m.self_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfAmount returns the old "self_amount" field's value of the ArchivementGeneral entity.
// If the ArchivementGeneral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementGeneralMutation) OldSelfAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfAmount: %w", err)
	}
	return oldValue.SelfAmount, nil
}

// ClearSelfAmount clears the value of the "self_amount" field.
func (m *ArchivementGeneralMutation) ClearSelfAmount() {
	m.self_amount = nil
	m.clearedFields[archivementgeneral.FieldSelfAmount] = struct{}{}
}

// SelfAmountCleared returns if the "self_amount" field was cleared in this mutation.
func (m *ArchivementGeneralMutation) SelfAmountCleared() bool {
	_, ok := m.clearedFields[archivementgeneral.FieldSelfAmount]
	return ok
}

// ResetSelfAmount resets all changes to the "self_amount" field.
func (m *ArchivementGeneralMutation) ResetSelfAmount() {
	m.self_amount = nil
	delete(m.clearedFields, archivementgeneral.FieldSelfAmount)
}

// SetTotalCommission sets the "total_commission" field.
func (m *ArchivementGeneralMutation) SetTotalCommission(d decimal.Decimal) {
	m.total_commission = &d
}

// TotalCommission returns the value of the "total_commission" field in the mutation.
func (m *ArchivementGeneralMutation) TotalCommission() (r decimal.Decimal, exists bool) {
	v := m.total_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCommission returns the old "total_commission" field's value of the ArchivementGeneral entity.
// If the ArchivementGeneral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementGeneralMutation) OldTotalCommission(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCommission: %w", err)
	}
	return oldValue.TotalCommission, nil
}

// ClearTotalCommission clears the value of the "total_commission" field.
func (m *ArchivementGeneralMutation) ClearTotalCommission() {
	m.total_commission = nil
	m.clearedFields[archivementgeneral.FieldTotalCommission] = struct{}{}
}

// TotalCommissionCleared returns if the "total_commission" field was cleared in this mutation.
func (m *ArchivementGeneralMutation) TotalCommissionCleared() bool {
	_, ok := m.clearedFields[archivementgeneral.FieldTotalCommission]
	return ok
}

// ResetTotalCommission resets all changes to the "total_commission" field.
func (m *ArchivementGeneralMutation) ResetTotalCommission() {
	m.total_commission = nil
	delete(m.clearedFields, archivementgeneral.FieldTotalCommission)
}

// SetSelfCommission sets the "self_commission" field.
func (m *ArchivementGeneralMutation) SetSelfCommission(d decimal.Decimal) {
	m.self_commission = &d
}

// SelfCommission returns the value of the "self_commission" field in the mutation.
func (m *ArchivementGeneralMutation) SelfCommission() (r decimal.Decimal, exists bool) {
	v := m.self_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfCommission returns the old "self_commission" field's value of the ArchivementGeneral entity.
// If the ArchivementGeneral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivementGeneralMutation) OldSelfCommission(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfCommission: %w", err)
	}
	return oldValue.SelfCommission, nil
}

// ClearSelfCommission clears the value of the "self_commission" field.
func (m *ArchivementGeneralMutation) ClearSelfCommission() {
	m.self_commission = nil
	m.clearedFields[archivementgeneral.FieldSelfCommission] = struct{}{}
}

// SelfCommissionCleared returns if the "self_commission" field was cleared in this mutation.
func (m *ArchivementGeneralMutation) SelfCommissionCleared() bool {
	_, ok := m.clearedFields[archivementgeneral.FieldSelfCommission]
	return ok
}

// ResetSelfCommission resets all changes to the "self_commission" field.
func (m *ArchivementGeneralMutation) ResetSelfCommission() {
	m.self_commission = nil
	delete(m.clearedFields, archivementgeneral.FieldSelfCommission)
}

// Where appends a list predicates to the ArchivementGeneralMutation builder.
func (m *ArchivementGeneralMutation) Where(ps ...predicate.ArchivementGeneral) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ArchivementGeneralMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ArchivementGeneral).
func (m *ArchivementGeneralMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArchivementGeneralMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, archivementgeneral.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, archivementgeneral.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, archivementgeneral.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, archivementgeneral.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, archivementgeneral.FieldUserID)
	}
	if m.good_id != nil {
		fields = append(fields, archivementgeneral.FieldGoodID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, archivementgeneral.FieldCoinTypeID)
	}
	if m.total_units != nil {
		fields = append(fields, archivementgeneral.FieldTotalUnits)
	}
	if m.self_units != nil {
		fields = append(fields, archivementgeneral.FieldSelfUnits)
	}
	if m.total_amount != nil {
		fields = append(fields, archivementgeneral.FieldTotalAmount)
	}
	if m.self_amount != nil {
		fields = append(fields, archivementgeneral.FieldSelfAmount)
	}
	if m.total_commission != nil {
		fields = append(fields, archivementgeneral.FieldTotalCommission)
	}
	if m.self_commission != nil {
		fields = append(fields, archivementgeneral.FieldSelfCommission)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArchivementGeneralMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case archivementgeneral.FieldCreatedAt:
		return m.CreatedAt()
	case archivementgeneral.FieldUpdatedAt:
		return m.UpdatedAt()
	case archivementgeneral.FieldDeletedAt:
		return m.DeletedAt()
	case archivementgeneral.FieldAppID:
		return m.AppID()
	case archivementgeneral.FieldUserID:
		return m.UserID()
	case archivementgeneral.FieldGoodID:
		return m.GoodID()
	case archivementgeneral.FieldCoinTypeID:
		return m.CoinTypeID()
	case archivementgeneral.FieldTotalUnits:
		return m.TotalUnits()
	case archivementgeneral.FieldSelfUnits:
		return m.SelfUnits()
	case archivementgeneral.FieldTotalAmount:
		return m.TotalAmount()
	case archivementgeneral.FieldSelfAmount:
		return m.SelfAmount()
	case archivementgeneral.FieldTotalCommission:
		return m.TotalCommission()
	case archivementgeneral.FieldSelfCommission:
		return m.SelfCommission()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArchivementGeneralMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case archivementgeneral.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case archivementgeneral.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case archivementgeneral.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case archivementgeneral.FieldAppID:
		return m.OldAppID(ctx)
	case archivementgeneral.FieldUserID:
		return m.OldUserID(ctx)
	case archivementgeneral.FieldGoodID:
		return m.OldGoodID(ctx)
	case archivementgeneral.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case archivementgeneral.FieldTotalUnits:
		return m.OldTotalUnits(ctx)
	case archivementgeneral.FieldSelfUnits:
		return m.OldSelfUnits(ctx)
	case archivementgeneral.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case archivementgeneral.FieldSelfAmount:
		return m.OldSelfAmount(ctx)
	case archivementgeneral.FieldTotalCommission:
		return m.OldTotalCommission(ctx)
	case archivementgeneral.FieldSelfCommission:
		return m.OldSelfCommission(ctx)
	}
	return nil, fmt.Errorf("unknown ArchivementGeneral field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArchivementGeneralMutation) SetField(name string, value ent.Value) error {
	switch name {
	case archivementgeneral.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case archivementgeneral.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case archivementgeneral.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case archivementgeneral.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case archivementgeneral.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case archivementgeneral.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case archivementgeneral.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case archivementgeneral.FieldTotalUnits:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalUnits(v)
		return nil
	case archivementgeneral.FieldSelfUnits:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfUnits(v)
		return nil
	case archivementgeneral.FieldTotalAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case archivementgeneral.FieldSelfAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfAmount(v)
		return nil
	case archivementgeneral.FieldTotalCommission:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCommission(v)
		return nil
	case archivementgeneral.FieldSelfCommission:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfCommission(v)
		return nil
	}
	return fmt.Errorf("unknown ArchivementGeneral field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArchivementGeneralMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, archivementgeneral.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, archivementgeneral.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, archivementgeneral.FieldDeletedAt)
	}
	if m.addtotal_units != nil {
		fields = append(fields, archivementgeneral.FieldTotalUnits)
	}
	if m.addself_units != nil {
		fields = append(fields, archivementgeneral.FieldSelfUnits)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArchivementGeneralMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case archivementgeneral.FieldCreatedAt:
		return m.AddedCreatedAt()
	case archivementgeneral.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case archivementgeneral.FieldDeletedAt:
		return m.AddedDeletedAt()
	case archivementgeneral.FieldTotalUnits:
		return m.AddedTotalUnits()
	case archivementgeneral.FieldSelfUnits:
		return m.AddedSelfUnits()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArchivementGeneralMutation) AddField(name string, value ent.Value) error {
	switch name {
	case archivementgeneral.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case archivementgeneral.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case archivementgeneral.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case archivementgeneral.FieldTotalUnits:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalUnits(v)
		return nil
	case archivementgeneral.FieldSelfUnits:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSelfUnits(v)
		return nil
	}
	return fmt.Errorf("unknown ArchivementGeneral numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArchivementGeneralMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(archivementgeneral.FieldAppID) {
		fields = append(fields, archivementgeneral.FieldAppID)
	}
	if m.FieldCleared(archivementgeneral.FieldUserID) {
		fields = append(fields, archivementgeneral.FieldUserID)
	}
	if m.FieldCleared(archivementgeneral.FieldGoodID) {
		fields = append(fields, archivementgeneral.FieldGoodID)
	}
	if m.FieldCleared(archivementgeneral.FieldCoinTypeID) {
		fields = append(fields, archivementgeneral.FieldCoinTypeID)
	}
	if m.FieldCleared(archivementgeneral.FieldTotalUnits) {
		fields = append(fields, archivementgeneral.FieldTotalUnits)
	}
	if m.FieldCleared(archivementgeneral.FieldSelfUnits) {
		fields = append(fields, archivementgeneral.FieldSelfUnits)
	}
	if m.FieldCleared(archivementgeneral.FieldTotalAmount) {
		fields = append(fields, archivementgeneral.FieldTotalAmount)
	}
	if m.FieldCleared(archivementgeneral.FieldSelfAmount) {
		fields = append(fields, archivementgeneral.FieldSelfAmount)
	}
	if m.FieldCleared(archivementgeneral.FieldTotalCommission) {
		fields = append(fields, archivementgeneral.FieldTotalCommission)
	}
	if m.FieldCleared(archivementgeneral.FieldSelfCommission) {
		fields = append(fields, archivementgeneral.FieldSelfCommission)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArchivementGeneralMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArchivementGeneralMutation) ClearField(name string) error {
	switch name {
	case archivementgeneral.FieldAppID:
		m.ClearAppID()
		return nil
	case archivementgeneral.FieldUserID:
		m.ClearUserID()
		return nil
	case archivementgeneral.FieldGoodID:
		m.ClearGoodID()
		return nil
	case archivementgeneral.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case archivementgeneral.FieldTotalUnits:
		m.ClearTotalUnits()
		return nil
	case archivementgeneral.FieldSelfUnits:
		m.ClearSelfUnits()
		return nil
	case archivementgeneral.FieldTotalAmount:
		m.ClearTotalAmount()
		return nil
	case archivementgeneral.FieldSelfAmount:
		m.ClearSelfAmount()
		return nil
	case archivementgeneral.FieldTotalCommission:
		m.ClearTotalCommission()
		return nil
	case archivementgeneral.FieldSelfCommission:
		m.ClearSelfCommission()
		return nil
	}
	return fmt.Errorf("unknown ArchivementGeneral nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArchivementGeneralMutation) ResetField(name string) error {
	switch name {
	case archivementgeneral.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case archivementgeneral.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case archivementgeneral.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case archivementgeneral.FieldAppID:
		m.ResetAppID()
		return nil
	case archivementgeneral.FieldUserID:
		m.ResetUserID()
		return nil
	case archivementgeneral.FieldGoodID:
		m.ResetGoodID()
		return nil
	case archivementgeneral.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case archivementgeneral.FieldTotalUnits:
		m.ResetTotalUnits()
		return nil
	case archivementgeneral.FieldSelfUnits:
		m.ResetSelfUnits()
		return nil
	case archivementgeneral.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case archivementgeneral.FieldSelfAmount:
		m.ResetSelfAmount()
		return nil
	case archivementgeneral.FieldTotalCommission:
		m.ResetTotalCommission()
		return nil
	case archivementgeneral.FieldSelfCommission:
		m.ResetSelfCommission()
		return nil
	}
	return fmt.Errorf("unknown ArchivementGeneral field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArchivementGeneralMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArchivementGeneralMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArchivementGeneralMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArchivementGeneralMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArchivementGeneralMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArchivementGeneralMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArchivementGeneralMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ArchivementGeneral unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArchivementGeneralMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ArchivementGeneral edge %s", name)
}

// CouponAllocatedMutation represents an operation that mutates the CouponAllocated nodes in the graph.
type CouponAllocatedMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	app_id           *uuid.UUID
	user_id          *uuid.UUID
	coupon_type      *string
	coupon_id        *uuid.UUID
	value            *decimal.Decimal
	used             *bool
	used_at          *uint32
	addused_at       *int32
	used_by_order_id *uuid.UUID
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*CouponAllocated, error)
	predicates       []predicate.CouponAllocated
}

var _ ent.Mutation = (*CouponAllocatedMutation)(nil)

// couponallocatedOption allows management of the mutation configuration using functional options.
type couponallocatedOption func(*CouponAllocatedMutation)

// newCouponAllocatedMutation creates new mutation for the CouponAllocated entity.
func newCouponAllocatedMutation(c config, op Op, opts ...couponallocatedOption) *CouponAllocatedMutation {
	m := &CouponAllocatedMutation{
		config:        c,
		op:            op,
		typ:           TypeCouponAllocated,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponAllocatedID sets the ID field of the mutation.
func withCouponAllocatedID(id uuid.UUID) couponallocatedOption {
	return func(m *CouponAllocatedMutation) {
		var (
			err   error
			once  sync.Once
			value *CouponAllocated
		)
		m.oldValue = func(ctx context.Context) (*CouponAllocated, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CouponAllocated.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCouponAllocated sets the old CouponAllocated of the mutation.
func withCouponAllocated(node *CouponAllocated) couponallocatedOption {
	return func(m *CouponAllocatedMutation) {
		m.oldValue = func(context.Context) (*CouponAllocated, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponAllocatedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponAllocatedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CouponAllocated entities.
func (m *CouponAllocatedMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponAllocatedMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponAllocatedMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CouponAllocated.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponAllocatedMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponAllocatedMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CouponAllocatedMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CouponAllocatedMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponAllocatedMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponAllocatedMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponAllocatedMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CouponAllocatedMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CouponAllocatedMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponAllocatedMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CouponAllocatedMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CouponAllocatedMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CouponAllocatedMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CouponAllocatedMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CouponAllocatedMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *CouponAllocatedMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CouponAllocatedMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CouponAllocatedMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *CouponAllocatedMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CouponAllocatedMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CouponAllocatedMutation) ResetUserID() {
	m.user_id = nil
}

// SetCouponType sets the "coupon_type" field.
func (m *CouponAllocatedMutation) SetCouponType(s string) {
	m.coupon_type = &s
}

// CouponType returns the value of the "coupon_type" field in the mutation.
func (m *CouponAllocatedMutation) CouponType() (r string, exists bool) {
	v := m.coupon_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponType returns the old "coupon_type" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldCouponType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponType: %w", err)
	}
	return oldValue.CouponType, nil
}

// ClearCouponType clears the value of the "coupon_type" field.
func (m *CouponAllocatedMutation) ClearCouponType() {
	m.coupon_type = nil
	m.clearedFields[couponallocated.FieldCouponType] = struct{}{}
}

// CouponTypeCleared returns if the "coupon_type" field was cleared in this mutation.
func (m *CouponAllocatedMutation) CouponTypeCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldCouponType]
	return ok
}

// ResetCouponType resets all changes to the "coupon_type" field.
func (m *CouponAllocatedMutation) ResetCouponType() {
	m.coupon_type = nil
	delete(m.clearedFields, couponallocated.FieldCouponType)
}

// SetCouponID sets the "coupon_id" field.
func (m *CouponAllocatedMutation) SetCouponID(u uuid.UUID) {
	m.coupon_id = &u
}

// CouponID returns the value of the "coupon_id" field in the mutation.
func (m *CouponAllocatedMutation) CouponID() (r uuid.UUID, exists bool) {
	v := m.coupon_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponID returns the old "coupon_id" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldCouponID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponID: %w", err)
	}
	return oldValue.CouponID, nil
}

// ResetCouponID resets all changes to the "coupon_id" field.
func (m *CouponAllocatedMutation) ResetCouponID() {
	m.coupon_id = nil
}

// SetValue sets the "value" field.
func (m *CouponAllocatedMutation) SetValue(d decimal.Decimal) {
	m.value = &d
}

// Value returns the value of the "value" field in the mutation.
func (m *CouponAllocatedMutation) Value() (r decimal.Decimal, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *CouponAllocatedMutation) ClearValue() {
	m.value = nil
	m.clearedFields[couponallocated.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *CouponAllocatedMutation) ValueCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *CouponAllocatedMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, couponallocated.FieldValue)
}

// SetUsed sets the "used" field.
func (m *CouponAllocatedMutation) SetUsed(b bool) {
	m.used = &b
}

// Used returns the value of the "used" field in the mutation.
func (m *CouponAllocatedMutation) Used() (r bool, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// ClearUsed clears the value of the "used" field.
func (m *CouponAllocatedMutation) ClearUsed() {
	m.used = nil
	m.clearedFields[couponallocated.FieldUsed] = struct{}{}
}

// UsedCleared returns if the "used" field was cleared in this mutation.
func (m *CouponAllocatedMutation) UsedCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldUsed]
	return ok
}

// ResetUsed resets all changes to the "used" field.
func (m *CouponAllocatedMutation) ResetUsed() {
	m.used = nil
	delete(m.clearedFields, couponallocated.FieldUsed)
}

// SetUsedAt sets the "used_at" field.
func (m *CouponAllocatedMutation) SetUsedAt(u uint32) {
	m.used_at = &u
	m.addused_at = nil
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *CouponAllocatedMutation) UsedAt() (r uint32, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldUsedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// AddUsedAt adds u to the "used_at" field.
func (m *CouponAllocatedMutation) AddUsedAt(u int32) {
	if m.addused_at != nil {
		*m.addused_at += u
	} else {
		m.addused_at = &u
	}
}

// AddedUsedAt returns the value that was added to the "used_at" field in this mutation.
func (m *CouponAllocatedMutation) AddedUsedAt() (r int32, exists bool) {
	v := m.addused_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *CouponAllocatedMutation) ClearUsedAt() {
	m.used_at = nil
	m.addused_at = nil
	m.clearedFields[couponallocated.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *CouponAllocatedMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *CouponAllocatedMutation) ResetUsedAt() {
	m.used_at = nil
	m.addused_at = nil
	delete(m.clearedFields, couponallocated.FieldUsedAt)
}

// SetUsedByOrderID sets the "used_by_order_id" field.
func (m *CouponAllocatedMutation) SetUsedByOrderID(u uuid.UUID) {
	m.used_by_order_id = &u
}

// UsedByOrderID returns the value of the "used_by_order_id" field in the mutation.
func (m *CouponAllocatedMutation) UsedByOrderID() (r uuid.UUID, exists bool) {
	v := m.used_by_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedByOrderID returns the old "used_by_order_id" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldUsedByOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedByOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedByOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedByOrderID: %w", err)
	}
	return oldValue.UsedByOrderID, nil
}

// ClearUsedByOrderID clears the value of the "used_by_order_id" field.
func (m *CouponAllocatedMutation) ClearUsedByOrderID() {
	m.used_by_order_id = nil
	m.clearedFields[couponallocated.FieldUsedByOrderID] = struct{}{}
}

// UsedByOrderIDCleared returns if the "used_by_order_id" field was cleared in this mutation.
func (m *CouponAllocatedMutation) UsedByOrderIDCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldUsedByOrderID]
	return ok
}

// ResetUsedByOrderID resets all changes to the "used_by_order_id" field.
func (m *CouponAllocatedMutation) ResetUsedByOrderID() {
	m.used_by_order_id = nil
	delete(m.clearedFields, couponallocated.FieldUsedByOrderID)
}

// Where appends a list predicates to the CouponAllocatedMutation builder.
func (m *CouponAllocatedMutation) Where(ps ...predicate.CouponAllocated) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CouponAllocatedMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CouponAllocated).
func (m *CouponAllocatedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponAllocatedMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, couponallocated.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, couponallocated.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, couponallocated.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, couponallocated.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, couponallocated.FieldUserID)
	}
	if m.coupon_type != nil {
		fields = append(fields, couponallocated.FieldCouponType)
	}
	if m.coupon_id != nil {
		fields = append(fields, couponallocated.FieldCouponID)
	}
	if m.value != nil {
		fields = append(fields, couponallocated.FieldValue)
	}
	if m.used != nil {
		fields = append(fields, couponallocated.FieldUsed)
	}
	if m.used_at != nil {
		fields = append(fields, couponallocated.FieldUsedAt)
	}
	if m.used_by_order_id != nil {
		fields = append(fields, couponallocated.FieldUsedByOrderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponAllocatedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case couponallocated.FieldCreatedAt:
		return m.CreatedAt()
	case couponallocated.FieldUpdatedAt:
		return m.UpdatedAt()
	case couponallocated.FieldDeletedAt:
		return m.DeletedAt()
	case couponallocated.FieldAppID:
		return m.AppID()
	case couponallocated.FieldUserID:
		return m.UserID()
	case couponallocated.FieldCouponType:
		return m.CouponType()
	case couponallocated.FieldCouponID:
		return m.CouponID()
	case couponallocated.FieldValue:
		return m.Value()
	case couponallocated.FieldUsed:
		return m.Used()
	case couponallocated.FieldUsedAt:
		return m.UsedAt()
	case couponallocated.FieldUsedByOrderID:
		return m.UsedByOrderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponAllocatedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case couponallocated.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case couponallocated.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case couponallocated.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case couponallocated.FieldAppID:
		return m.OldAppID(ctx)
	case couponallocated.FieldUserID:
		return m.OldUserID(ctx)
	case couponallocated.FieldCouponType:
		return m.OldCouponType(ctx)
	case couponallocated.FieldCouponID:
		return m.OldCouponID(ctx)
	case couponallocated.FieldValue:
		return m.OldValue(ctx)
	case couponallocated.FieldUsed:
		return m.OldUsed(ctx)
	case couponallocated.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case couponallocated.FieldUsedByOrderID:
		return m.OldUsedByOrderID(ctx)
	}
	return nil, fmt.Errorf("unknown CouponAllocated field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponAllocatedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case couponallocated.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case couponallocated.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case couponallocated.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case couponallocated.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case couponallocated.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case couponallocated.FieldCouponType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponType(v)
		return nil
	case couponallocated.FieldCouponID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponID(v)
		return nil
	case couponallocated.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case couponallocated.FieldUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	case couponallocated.FieldUsedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case couponallocated.FieldUsedByOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedByOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown CouponAllocated field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponAllocatedMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, couponallocated.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, couponallocated.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, couponallocated.FieldDeletedAt)
	}
	if m.addused_at != nil {
		fields = append(fields, couponallocated.FieldUsedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponAllocatedMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case couponallocated.FieldCreatedAt:
		return m.AddedCreatedAt()
	case couponallocated.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case couponallocated.FieldDeletedAt:
		return m.AddedDeletedAt()
	case couponallocated.FieldUsedAt:
		return m.AddedUsedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponAllocatedMutation) AddField(name string, value ent.Value) error {
	switch name {
	case couponallocated.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case couponallocated.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case couponallocated.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case couponallocated.FieldUsedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CouponAllocated numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponAllocatedMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(couponallocated.FieldCouponType) {
		fields = append(fields, couponallocated.FieldCouponType)
	}
	if m.FieldCleared(couponallocated.FieldValue) {
		fields = append(fields, couponallocated.FieldValue)
	}
	if m.FieldCleared(couponallocated.FieldUsed) {
		fields = append(fields, couponallocated.FieldUsed)
	}
	if m.FieldCleared(couponallocated.FieldUsedAt) {
		fields = append(fields, couponallocated.FieldUsedAt)
	}
	if m.FieldCleared(couponallocated.FieldUsedByOrderID) {
		fields = append(fields, couponallocated.FieldUsedByOrderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponAllocatedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponAllocatedMutation) ClearField(name string) error {
	switch name {
	case couponallocated.FieldCouponType:
		m.ClearCouponType()
		return nil
	case couponallocated.FieldValue:
		m.ClearValue()
		return nil
	case couponallocated.FieldUsed:
		m.ClearUsed()
		return nil
	case couponallocated.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	case couponallocated.FieldUsedByOrderID:
		m.ClearUsedByOrderID()
		return nil
	}
	return fmt.Errorf("unknown CouponAllocated nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponAllocatedMutation) ResetField(name string) error {
	switch name {
	case couponallocated.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case couponallocated.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case couponallocated.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case couponallocated.FieldAppID:
		m.ResetAppID()
		return nil
	case couponallocated.FieldUserID:
		m.ResetUserID()
		return nil
	case couponallocated.FieldCouponType:
		m.ResetCouponType()
		return nil
	case couponallocated.FieldCouponID:
		m.ResetCouponID()
		return nil
	case couponallocated.FieldValue:
		m.ResetValue()
		return nil
	case couponallocated.FieldUsed:
		m.ResetUsed()
		return nil
	case couponallocated.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case couponallocated.FieldUsedByOrderID:
		m.ResetUsedByOrderID()
		return nil
	}
	return fmt.Errorf("unknown CouponAllocated field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponAllocatedMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponAllocatedMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponAllocatedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponAllocatedMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponAllocatedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponAllocatedMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponAllocatedMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CouponAllocated unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponAllocatedMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CouponAllocated edge %s", name)
}

// CouponDiscountMutation represents an operation that mutates the CouponDiscount nodes in the graph.
type CouponDiscountMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *uint32
	addcreated_at       *int32
	updated_at          *uint32
	addupdated_at       *int32
	deleted_at          *uint32
	adddeleted_at       *int32
	app_id              *uuid.UUID
	discount            *decimal.Decimal
	circulation         *decimal.Decimal
	released_by_user_id *uuid.UUID
	start_at            *uint32
	addstart_at         *int32
	duration_days       *uint32
	addduration_days    *int32
	message             *string
	name                *string
	allocated           *uint32
	addallocated        *int32
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*CouponDiscount, error)
	predicates          []predicate.CouponDiscount
}

var _ ent.Mutation = (*CouponDiscountMutation)(nil)

// coupondiscountOption allows management of the mutation configuration using functional options.
type coupondiscountOption func(*CouponDiscountMutation)

// newCouponDiscountMutation creates new mutation for the CouponDiscount entity.
func newCouponDiscountMutation(c config, op Op, opts ...coupondiscountOption) *CouponDiscountMutation {
	m := &CouponDiscountMutation{
		config:        c,
		op:            op,
		typ:           TypeCouponDiscount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponDiscountID sets the ID field of the mutation.
func withCouponDiscountID(id uuid.UUID) coupondiscountOption {
	return func(m *CouponDiscountMutation) {
		var (
			err   error
			once  sync.Once
			value *CouponDiscount
		)
		m.oldValue = func(ctx context.Context) (*CouponDiscount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CouponDiscount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCouponDiscount sets the old CouponDiscount of the mutation.
func withCouponDiscount(node *CouponDiscount) coupondiscountOption {
	return func(m *CouponDiscountMutation) {
		m.oldValue = func(context.Context) (*CouponDiscount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponDiscountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponDiscountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CouponDiscount entities.
func (m *CouponDiscountMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponDiscountMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponDiscountMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CouponDiscount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponDiscountMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponDiscountMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CouponDiscount entity.
// If the CouponDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponDiscountMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CouponDiscountMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CouponDiscountMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponDiscountMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponDiscountMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponDiscountMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CouponDiscount entity.
// If the CouponDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponDiscountMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CouponDiscountMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CouponDiscountMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponDiscountMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CouponDiscountMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CouponDiscountMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CouponDiscount entity.
// If the CouponDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponDiscountMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CouponDiscountMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CouponDiscountMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CouponDiscountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *CouponDiscountMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CouponDiscountMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the CouponDiscount entity.
// If the CouponDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponDiscountMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CouponDiscountMutation) ResetAppID() {
	m.app_id = nil
}

// SetDiscount sets the "discount" field.
func (m *CouponDiscountMutation) SetDiscount(d decimal.Decimal) {
	m.discount = &d
}

// Discount returns the value of the "discount" field in the mutation.
func (m *CouponDiscountMutation) Discount() (r decimal.Decimal, exists bool) {
	v := m.discount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscount returns the old "discount" field's value of the CouponDiscount entity.
// If the CouponDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponDiscountMutation) OldDiscount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscount: %w", err)
	}
	return oldValue.Discount, nil
}

// ClearDiscount clears the value of the "discount" field.
func (m *CouponDiscountMutation) ClearDiscount() {
	m.discount = nil
	m.clearedFields[coupondiscount.FieldDiscount] = struct{}{}
}

// DiscountCleared returns if the "discount" field was cleared in this mutation.
func (m *CouponDiscountMutation) DiscountCleared() bool {
	_, ok := m.clearedFields[coupondiscount.FieldDiscount]
	return ok
}

// ResetDiscount resets all changes to the "discount" field.
func (m *CouponDiscountMutation) ResetDiscount() {
	m.discount = nil
	delete(m.clearedFields, coupondiscount.FieldDiscount)
}

// SetCirculation sets the "circulation" field.
func (m *CouponDiscountMutation) SetCirculation(d decimal.Decimal) {
	m.circulation = &d
}

// Circulation returns the value of the "circulation" field in the mutation.
func (m *CouponDiscountMutation) Circulation() (r decimal.Decimal, exists bool) {
	v := m.circulation
	if v == nil {
		return
	}
	return *v, true
}

// OldCirculation returns the old "circulation" field's value of the CouponDiscount entity.
// If the CouponDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponDiscountMutation) OldCirculation(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCirculation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCirculation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCirculation: %w", err)
	}
	return oldValue.Circulation, nil
}

// ClearCirculation clears the value of the "circulation" field.
func (m *CouponDiscountMutation) ClearCirculation() {
	m.circulation = nil
	m.clearedFields[coupondiscount.FieldCirculation] = struct{}{}
}

// CirculationCleared returns if the "circulation" field was cleared in this mutation.
func (m *CouponDiscountMutation) CirculationCleared() bool {
	_, ok := m.clearedFields[coupondiscount.FieldCirculation]
	return ok
}

// ResetCirculation resets all changes to the "circulation" field.
func (m *CouponDiscountMutation) ResetCirculation() {
	m.circulation = nil
	delete(m.clearedFields, coupondiscount.FieldCirculation)
}

// SetReleasedByUserID sets the "released_by_user_id" field.
func (m *CouponDiscountMutation) SetReleasedByUserID(u uuid.UUID) {
	m.released_by_user_id = &u
}

// ReleasedByUserID returns the value of the "released_by_user_id" field in the mutation.
func (m *CouponDiscountMutation) ReleasedByUserID() (r uuid.UUID, exists bool) {
	v := m.released_by_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReleasedByUserID returns the old "released_by_user_id" field's value of the CouponDiscount entity.
// If the CouponDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponDiscountMutation) OldReleasedByUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleasedByUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleasedByUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleasedByUserID: %w", err)
	}
	return oldValue.ReleasedByUserID, nil
}

// ResetReleasedByUserID resets all changes to the "released_by_user_id" field.
func (m *CouponDiscountMutation) ResetReleasedByUserID() {
	m.released_by_user_id = nil
}

// SetStartAt sets the "start_at" field.
func (m *CouponDiscountMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *CouponDiscountMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the CouponDiscount entity.
// If the CouponDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponDiscountMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *CouponDiscountMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *CouponDiscountMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *CouponDiscountMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[coupondiscount.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *CouponDiscountMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[coupondiscount.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *CouponDiscountMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, coupondiscount.FieldStartAt)
}

// SetDurationDays sets the "duration_days" field.
func (m *CouponDiscountMutation) SetDurationDays(u uint32) {
	m.duration_days = &u
	m.addduration_days = nil
}

// DurationDays returns the value of the "duration_days" field in the mutation.
func (m *CouponDiscountMutation) DurationDays() (r uint32, exists bool) {
	v := m.duration_days
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationDays returns the old "duration_days" field's value of the CouponDiscount entity.
// If the CouponDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponDiscountMutation) OldDurationDays(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationDays: %w", err)
	}
	return oldValue.DurationDays, nil
}

// AddDurationDays adds u to the "duration_days" field.
func (m *CouponDiscountMutation) AddDurationDays(u int32) {
	if m.addduration_days != nil {
		*m.addduration_days += u
	} else {
		m.addduration_days = &u
	}
}

// AddedDurationDays returns the value that was added to the "duration_days" field in this mutation.
func (m *CouponDiscountMutation) AddedDurationDays() (r int32, exists bool) {
	v := m.addduration_days
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationDays clears the value of the "duration_days" field.
func (m *CouponDiscountMutation) ClearDurationDays() {
	m.duration_days = nil
	m.addduration_days = nil
	m.clearedFields[coupondiscount.FieldDurationDays] = struct{}{}
}

// DurationDaysCleared returns if the "duration_days" field was cleared in this mutation.
func (m *CouponDiscountMutation) DurationDaysCleared() bool {
	_, ok := m.clearedFields[coupondiscount.FieldDurationDays]
	return ok
}

// ResetDurationDays resets all changes to the "duration_days" field.
func (m *CouponDiscountMutation) ResetDurationDays() {
	m.duration_days = nil
	m.addduration_days = nil
	delete(m.clearedFields, coupondiscount.FieldDurationDays)
}

// SetMessage sets the "message" field.
func (m *CouponDiscountMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *CouponDiscountMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the CouponDiscount entity.
// If the CouponDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponDiscountMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *CouponDiscountMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[coupondiscount.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *CouponDiscountMutation) MessageCleared() bool {
	_, ok := m.clearedFields[coupondiscount.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *CouponDiscountMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, coupondiscount.FieldMessage)
}

// SetName sets the "name" field.
func (m *CouponDiscountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CouponDiscountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CouponDiscount entity.
// If the CouponDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponDiscountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *CouponDiscountMutation) ClearName() {
	m.name = nil
	m.clearedFields[coupondiscount.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *CouponDiscountMutation) NameCleared() bool {
	_, ok := m.clearedFields[coupondiscount.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *CouponDiscountMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, coupondiscount.FieldName)
}

// SetAllocated sets the "allocated" field.
func (m *CouponDiscountMutation) SetAllocated(u uint32) {
	m.allocated = &u
	m.addallocated = nil
}

// Allocated returns the value of the "allocated" field in the mutation.
func (m *CouponDiscountMutation) Allocated() (r uint32, exists bool) {
	v := m.allocated
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocated returns the old "allocated" field's value of the CouponDiscount entity.
// If the CouponDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponDiscountMutation) OldAllocated(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllocated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllocated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocated: %w", err)
	}
	return oldValue.Allocated, nil
}

// AddAllocated adds u to the "allocated" field.
func (m *CouponDiscountMutation) AddAllocated(u int32) {
	if m.addallocated != nil {
		*m.addallocated += u
	} else {
		m.addallocated = &u
	}
}

// AddedAllocated returns the value that was added to the "allocated" field in this mutation.
func (m *CouponDiscountMutation) AddedAllocated() (r int32, exists bool) {
	v := m.addallocated
	if v == nil {
		return
	}
	return *v, true
}

// ClearAllocated clears the value of the "allocated" field.
func (m *CouponDiscountMutation) ClearAllocated() {
	m.allocated = nil
	m.addallocated = nil
	m.clearedFields[coupondiscount.FieldAllocated] = struct{}{}
}

// AllocatedCleared returns if the "allocated" field was cleared in this mutation.
func (m *CouponDiscountMutation) AllocatedCleared() bool {
	_, ok := m.clearedFields[coupondiscount.FieldAllocated]
	return ok
}

// ResetAllocated resets all changes to the "allocated" field.
func (m *CouponDiscountMutation) ResetAllocated() {
	m.allocated = nil
	m.addallocated = nil
	delete(m.clearedFields, coupondiscount.FieldAllocated)
}

// Where appends a list predicates to the CouponDiscountMutation builder.
func (m *CouponDiscountMutation) Where(ps ...predicate.CouponDiscount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CouponDiscountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CouponDiscount).
func (m *CouponDiscountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponDiscountMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, coupondiscount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coupondiscount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, coupondiscount.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, coupondiscount.FieldAppID)
	}
	if m.discount != nil {
		fields = append(fields, coupondiscount.FieldDiscount)
	}
	if m.circulation != nil {
		fields = append(fields, coupondiscount.FieldCirculation)
	}
	if m.released_by_user_id != nil {
		fields = append(fields, coupondiscount.FieldReleasedByUserID)
	}
	if m.start_at != nil {
		fields = append(fields, coupondiscount.FieldStartAt)
	}
	if m.duration_days != nil {
		fields = append(fields, coupondiscount.FieldDurationDays)
	}
	if m.message != nil {
		fields = append(fields, coupondiscount.FieldMessage)
	}
	if m.name != nil {
		fields = append(fields, coupondiscount.FieldName)
	}
	if m.allocated != nil {
		fields = append(fields, coupondiscount.FieldAllocated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponDiscountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coupondiscount.FieldCreatedAt:
		return m.CreatedAt()
	case coupondiscount.FieldUpdatedAt:
		return m.UpdatedAt()
	case coupondiscount.FieldDeletedAt:
		return m.DeletedAt()
	case coupondiscount.FieldAppID:
		return m.AppID()
	case coupondiscount.FieldDiscount:
		return m.Discount()
	case coupondiscount.FieldCirculation:
		return m.Circulation()
	case coupondiscount.FieldReleasedByUserID:
		return m.ReleasedByUserID()
	case coupondiscount.FieldStartAt:
		return m.StartAt()
	case coupondiscount.FieldDurationDays:
		return m.DurationDays()
	case coupondiscount.FieldMessage:
		return m.Message()
	case coupondiscount.FieldName:
		return m.Name()
	case coupondiscount.FieldAllocated:
		return m.Allocated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponDiscountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coupondiscount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coupondiscount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case coupondiscount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case coupondiscount.FieldAppID:
		return m.OldAppID(ctx)
	case coupondiscount.FieldDiscount:
		return m.OldDiscount(ctx)
	case coupondiscount.FieldCirculation:
		return m.OldCirculation(ctx)
	case coupondiscount.FieldReleasedByUserID:
		return m.OldReleasedByUserID(ctx)
	case coupondiscount.FieldStartAt:
		return m.OldStartAt(ctx)
	case coupondiscount.FieldDurationDays:
		return m.OldDurationDays(ctx)
	case coupondiscount.FieldMessage:
		return m.OldMessage(ctx)
	case coupondiscount.FieldName:
		return m.OldName(ctx)
	case coupondiscount.FieldAllocated:
		return m.OldAllocated(ctx)
	}
	return nil, fmt.Errorf("unknown CouponDiscount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponDiscountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coupondiscount.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coupondiscount.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case coupondiscount.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case coupondiscount.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case coupondiscount.FieldDiscount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscount(v)
		return nil
	case coupondiscount.FieldCirculation:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCirculation(v)
		return nil
	case coupondiscount.FieldReleasedByUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleasedByUserID(v)
		return nil
	case coupondiscount.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case coupondiscount.FieldDurationDays:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationDays(v)
		return nil
	case coupondiscount.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case coupondiscount.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case coupondiscount.FieldAllocated:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocated(v)
		return nil
	}
	return fmt.Errorf("unknown CouponDiscount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponDiscountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, coupondiscount.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, coupondiscount.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, coupondiscount.FieldDeletedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, coupondiscount.FieldStartAt)
	}
	if m.addduration_days != nil {
		fields = append(fields, coupondiscount.FieldDurationDays)
	}
	if m.addallocated != nil {
		fields = append(fields, coupondiscount.FieldAllocated)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponDiscountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coupondiscount.FieldCreatedAt:
		return m.AddedCreatedAt()
	case coupondiscount.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case coupondiscount.FieldDeletedAt:
		return m.AddedDeletedAt()
	case coupondiscount.FieldStartAt:
		return m.AddedStartAt()
	case coupondiscount.FieldDurationDays:
		return m.AddedDurationDays()
	case coupondiscount.FieldAllocated:
		return m.AddedAllocated()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponDiscountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coupondiscount.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case coupondiscount.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case coupondiscount.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case coupondiscount.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case coupondiscount.FieldDurationDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationDays(v)
		return nil
	case coupondiscount.FieldAllocated:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllocated(v)
		return nil
	}
	return fmt.Errorf("unknown CouponDiscount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponDiscountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coupondiscount.FieldDiscount) {
		fields = append(fields, coupondiscount.FieldDiscount)
	}
	if m.FieldCleared(coupondiscount.FieldCirculation) {
		fields = append(fields, coupondiscount.FieldCirculation)
	}
	if m.FieldCleared(coupondiscount.FieldStartAt) {
		fields = append(fields, coupondiscount.FieldStartAt)
	}
	if m.FieldCleared(coupondiscount.FieldDurationDays) {
		fields = append(fields, coupondiscount.FieldDurationDays)
	}
	if m.FieldCleared(coupondiscount.FieldMessage) {
		fields = append(fields, coupondiscount.FieldMessage)
	}
	if m.FieldCleared(coupondiscount.FieldName) {
		fields = append(fields, coupondiscount.FieldName)
	}
	if m.FieldCleared(coupondiscount.FieldAllocated) {
		fields = append(fields, coupondiscount.FieldAllocated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponDiscountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponDiscountMutation) ClearField(name string) error {
	switch name {
	case coupondiscount.FieldDiscount:
		m.ClearDiscount()
		return nil
	case coupondiscount.FieldCirculation:
		m.ClearCirculation()
		return nil
	case coupondiscount.FieldStartAt:
		m.ClearStartAt()
		return nil
	case coupondiscount.FieldDurationDays:
		m.ClearDurationDays()
		return nil
	case coupondiscount.FieldMessage:
		m.ClearMessage()
		return nil
	case coupondiscount.FieldName:
		m.ClearName()
		return nil
	case coupondiscount.FieldAllocated:
		m.ClearAllocated()
		return nil
	}
	return fmt.Errorf("unknown CouponDiscount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponDiscountMutation) ResetField(name string) error {
	switch name {
	case coupondiscount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coupondiscount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case coupondiscount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case coupondiscount.FieldAppID:
		m.ResetAppID()
		return nil
	case coupondiscount.FieldDiscount:
		m.ResetDiscount()
		return nil
	case coupondiscount.FieldCirculation:
		m.ResetCirculation()
		return nil
	case coupondiscount.FieldReleasedByUserID:
		m.ResetReleasedByUserID()
		return nil
	case coupondiscount.FieldStartAt:
		m.ResetStartAt()
		return nil
	case coupondiscount.FieldDurationDays:
		m.ResetDurationDays()
		return nil
	case coupondiscount.FieldMessage:
		m.ResetMessage()
		return nil
	case coupondiscount.FieldName:
		m.ResetName()
		return nil
	case coupondiscount.FieldAllocated:
		m.ResetAllocated()
		return nil
	}
	return fmt.Errorf("unknown CouponDiscount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponDiscountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponDiscountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponDiscountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponDiscountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponDiscountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponDiscountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponDiscountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CouponDiscount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponDiscountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CouponDiscount edge %s", name)
}

// CouponFixAmountMutation represents an operation that mutates the CouponFixAmount nodes in the graph.
type CouponFixAmountMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *uint32
	addcreated_at       *int32
	updated_at          *uint32
	addupdated_at       *int32
	deleted_at          *uint32
	adddeleted_at       *int32
	app_id              *uuid.UUID
	denomination        *decimal.Decimal
	circulation         *decimal.Decimal
	released_by_user_id *uuid.UUID
	start_at            *uint32
	addstart_at         *int32
	duration_days       *uint32
	addduration_days    *int32
	message             *string
	name                *string
	allocated           *uint32
	addallocated        *int32
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*CouponFixAmount, error)
	predicates          []predicate.CouponFixAmount
}

var _ ent.Mutation = (*CouponFixAmountMutation)(nil)

// couponfixamountOption allows management of the mutation configuration using functional options.
type couponfixamountOption func(*CouponFixAmountMutation)

// newCouponFixAmountMutation creates new mutation for the CouponFixAmount entity.
func newCouponFixAmountMutation(c config, op Op, opts ...couponfixamountOption) *CouponFixAmountMutation {
	m := &CouponFixAmountMutation{
		config:        c,
		op:            op,
		typ:           TypeCouponFixAmount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponFixAmountID sets the ID field of the mutation.
func withCouponFixAmountID(id uuid.UUID) couponfixamountOption {
	return func(m *CouponFixAmountMutation) {
		var (
			err   error
			once  sync.Once
			value *CouponFixAmount
		)
		m.oldValue = func(ctx context.Context) (*CouponFixAmount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CouponFixAmount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCouponFixAmount sets the old CouponFixAmount of the mutation.
func withCouponFixAmount(node *CouponFixAmount) couponfixamountOption {
	return func(m *CouponFixAmountMutation) {
		m.oldValue = func(context.Context) (*CouponFixAmount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponFixAmountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponFixAmountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CouponFixAmount entities.
func (m *CouponFixAmountMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponFixAmountMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponFixAmountMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CouponFixAmount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponFixAmountMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponFixAmountMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CouponFixAmount entity.
// If the CouponFixAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponFixAmountMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CouponFixAmountMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CouponFixAmountMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponFixAmountMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponFixAmountMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponFixAmountMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CouponFixAmount entity.
// If the CouponFixAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponFixAmountMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CouponFixAmountMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CouponFixAmountMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponFixAmountMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CouponFixAmountMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CouponFixAmountMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CouponFixAmount entity.
// If the CouponFixAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponFixAmountMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CouponFixAmountMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CouponFixAmountMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CouponFixAmountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *CouponFixAmountMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CouponFixAmountMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the CouponFixAmount entity.
// If the CouponFixAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponFixAmountMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CouponFixAmountMutation) ResetAppID() {
	m.app_id = nil
}

// SetDenomination sets the "denomination" field.
func (m *CouponFixAmountMutation) SetDenomination(d decimal.Decimal) {
	m.denomination = &d
}

// Denomination returns the value of the "denomination" field in the mutation.
func (m *CouponFixAmountMutation) Denomination() (r decimal.Decimal, exists bool) {
	v := m.denomination
	if v == nil {
		return
	}
	return *v, true
}

// OldDenomination returns the old "denomination" field's value of the CouponFixAmount entity.
// If the CouponFixAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponFixAmountMutation) OldDenomination(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDenomination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDenomination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDenomination: %w", err)
	}
	return oldValue.Denomination, nil
}

// ClearDenomination clears the value of the "denomination" field.
func (m *CouponFixAmountMutation) ClearDenomination() {
	m.denomination = nil
	m.clearedFields[couponfixamount.FieldDenomination] = struct{}{}
}

// DenominationCleared returns if the "denomination" field was cleared in this mutation.
func (m *CouponFixAmountMutation) DenominationCleared() bool {
	_, ok := m.clearedFields[couponfixamount.FieldDenomination]
	return ok
}

// ResetDenomination resets all changes to the "denomination" field.
func (m *CouponFixAmountMutation) ResetDenomination() {
	m.denomination = nil
	delete(m.clearedFields, couponfixamount.FieldDenomination)
}

// SetCirculation sets the "circulation" field.
func (m *CouponFixAmountMutation) SetCirculation(d decimal.Decimal) {
	m.circulation = &d
}

// Circulation returns the value of the "circulation" field in the mutation.
func (m *CouponFixAmountMutation) Circulation() (r decimal.Decimal, exists bool) {
	v := m.circulation
	if v == nil {
		return
	}
	return *v, true
}

// OldCirculation returns the old "circulation" field's value of the CouponFixAmount entity.
// If the CouponFixAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponFixAmountMutation) OldCirculation(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCirculation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCirculation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCirculation: %w", err)
	}
	return oldValue.Circulation, nil
}

// ClearCirculation clears the value of the "circulation" field.
func (m *CouponFixAmountMutation) ClearCirculation() {
	m.circulation = nil
	m.clearedFields[couponfixamount.FieldCirculation] = struct{}{}
}

// CirculationCleared returns if the "circulation" field was cleared in this mutation.
func (m *CouponFixAmountMutation) CirculationCleared() bool {
	_, ok := m.clearedFields[couponfixamount.FieldCirculation]
	return ok
}

// ResetCirculation resets all changes to the "circulation" field.
func (m *CouponFixAmountMutation) ResetCirculation() {
	m.circulation = nil
	delete(m.clearedFields, couponfixamount.FieldCirculation)
}

// SetReleasedByUserID sets the "released_by_user_id" field.
func (m *CouponFixAmountMutation) SetReleasedByUserID(u uuid.UUID) {
	m.released_by_user_id = &u
}

// ReleasedByUserID returns the value of the "released_by_user_id" field in the mutation.
func (m *CouponFixAmountMutation) ReleasedByUserID() (r uuid.UUID, exists bool) {
	v := m.released_by_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReleasedByUserID returns the old "released_by_user_id" field's value of the CouponFixAmount entity.
// If the CouponFixAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponFixAmountMutation) OldReleasedByUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleasedByUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleasedByUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleasedByUserID: %w", err)
	}
	return oldValue.ReleasedByUserID, nil
}

// ResetReleasedByUserID resets all changes to the "released_by_user_id" field.
func (m *CouponFixAmountMutation) ResetReleasedByUserID() {
	m.released_by_user_id = nil
}

// SetStartAt sets the "start_at" field.
func (m *CouponFixAmountMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *CouponFixAmountMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the CouponFixAmount entity.
// If the CouponFixAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponFixAmountMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *CouponFixAmountMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *CouponFixAmountMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *CouponFixAmountMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[couponfixamount.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *CouponFixAmountMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[couponfixamount.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *CouponFixAmountMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, couponfixamount.FieldStartAt)
}

// SetDurationDays sets the "duration_days" field.
func (m *CouponFixAmountMutation) SetDurationDays(u uint32) {
	m.duration_days = &u
	m.addduration_days = nil
}

// DurationDays returns the value of the "duration_days" field in the mutation.
func (m *CouponFixAmountMutation) DurationDays() (r uint32, exists bool) {
	v := m.duration_days
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationDays returns the old "duration_days" field's value of the CouponFixAmount entity.
// If the CouponFixAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponFixAmountMutation) OldDurationDays(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationDays: %w", err)
	}
	return oldValue.DurationDays, nil
}

// AddDurationDays adds u to the "duration_days" field.
func (m *CouponFixAmountMutation) AddDurationDays(u int32) {
	if m.addduration_days != nil {
		*m.addduration_days += u
	} else {
		m.addduration_days = &u
	}
}

// AddedDurationDays returns the value that was added to the "duration_days" field in this mutation.
func (m *CouponFixAmountMutation) AddedDurationDays() (r int32, exists bool) {
	v := m.addduration_days
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationDays clears the value of the "duration_days" field.
func (m *CouponFixAmountMutation) ClearDurationDays() {
	m.duration_days = nil
	m.addduration_days = nil
	m.clearedFields[couponfixamount.FieldDurationDays] = struct{}{}
}

// DurationDaysCleared returns if the "duration_days" field was cleared in this mutation.
func (m *CouponFixAmountMutation) DurationDaysCleared() bool {
	_, ok := m.clearedFields[couponfixamount.FieldDurationDays]
	return ok
}

// ResetDurationDays resets all changes to the "duration_days" field.
func (m *CouponFixAmountMutation) ResetDurationDays() {
	m.duration_days = nil
	m.addduration_days = nil
	delete(m.clearedFields, couponfixamount.FieldDurationDays)
}

// SetMessage sets the "message" field.
func (m *CouponFixAmountMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *CouponFixAmountMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the CouponFixAmount entity.
// If the CouponFixAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponFixAmountMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *CouponFixAmountMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[couponfixamount.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *CouponFixAmountMutation) MessageCleared() bool {
	_, ok := m.clearedFields[couponfixamount.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *CouponFixAmountMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, couponfixamount.FieldMessage)
}

// SetName sets the "name" field.
func (m *CouponFixAmountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CouponFixAmountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CouponFixAmount entity.
// If the CouponFixAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponFixAmountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *CouponFixAmountMutation) ClearName() {
	m.name = nil
	m.clearedFields[couponfixamount.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *CouponFixAmountMutation) NameCleared() bool {
	_, ok := m.clearedFields[couponfixamount.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *CouponFixAmountMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, couponfixamount.FieldName)
}

// SetAllocated sets the "allocated" field.
func (m *CouponFixAmountMutation) SetAllocated(u uint32) {
	m.allocated = &u
	m.addallocated = nil
}

// Allocated returns the value of the "allocated" field in the mutation.
func (m *CouponFixAmountMutation) Allocated() (r uint32, exists bool) {
	v := m.allocated
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocated returns the old "allocated" field's value of the CouponFixAmount entity.
// If the CouponFixAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponFixAmountMutation) OldAllocated(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllocated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllocated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocated: %w", err)
	}
	return oldValue.Allocated, nil
}

// AddAllocated adds u to the "allocated" field.
func (m *CouponFixAmountMutation) AddAllocated(u int32) {
	if m.addallocated != nil {
		*m.addallocated += u
	} else {
		m.addallocated = &u
	}
}

// AddedAllocated returns the value that was added to the "allocated" field in this mutation.
func (m *CouponFixAmountMutation) AddedAllocated() (r int32, exists bool) {
	v := m.addallocated
	if v == nil {
		return
	}
	return *v, true
}

// ClearAllocated clears the value of the "allocated" field.
func (m *CouponFixAmountMutation) ClearAllocated() {
	m.allocated = nil
	m.addallocated = nil
	m.clearedFields[couponfixamount.FieldAllocated] = struct{}{}
}

// AllocatedCleared returns if the "allocated" field was cleared in this mutation.
func (m *CouponFixAmountMutation) AllocatedCleared() bool {
	_, ok := m.clearedFields[couponfixamount.FieldAllocated]
	return ok
}

// ResetAllocated resets all changes to the "allocated" field.
func (m *CouponFixAmountMutation) ResetAllocated() {
	m.allocated = nil
	m.addallocated = nil
	delete(m.clearedFields, couponfixamount.FieldAllocated)
}

// Where appends a list predicates to the CouponFixAmountMutation builder.
func (m *CouponFixAmountMutation) Where(ps ...predicate.CouponFixAmount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CouponFixAmountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CouponFixAmount).
func (m *CouponFixAmountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponFixAmountMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, couponfixamount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, couponfixamount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, couponfixamount.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, couponfixamount.FieldAppID)
	}
	if m.denomination != nil {
		fields = append(fields, couponfixamount.FieldDenomination)
	}
	if m.circulation != nil {
		fields = append(fields, couponfixamount.FieldCirculation)
	}
	if m.released_by_user_id != nil {
		fields = append(fields, couponfixamount.FieldReleasedByUserID)
	}
	if m.start_at != nil {
		fields = append(fields, couponfixamount.FieldStartAt)
	}
	if m.duration_days != nil {
		fields = append(fields, couponfixamount.FieldDurationDays)
	}
	if m.message != nil {
		fields = append(fields, couponfixamount.FieldMessage)
	}
	if m.name != nil {
		fields = append(fields, couponfixamount.FieldName)
	}
	if m.allocated != nil {
		fields = append(fields, couponfixamount.FieldAllocated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponFixAmountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case couponfixamount.FieldCreatedAt:
		return m.CreatedAt()
	case couponfixamount.FieldUpdatedAt:
		return m.UpdatedAt()
	case couponfixamount.FieldDeletedAt:
		return m.DeletedAt()
	case couponfixamount.FieldAppID:
		return m.AppID()
	case couponfixamount.FieldDenomination:
		return m.Denomination()
	case couponfixamount.FieldCirculation:
		return m.Circulation()
	case couponfixamount.FieldReleasedByUserID:
		return m.ReleasedByUserID()
	case couponfixamount.FieldStartAt:
		return m.StartAt()
	case couponfixamount.FieldDurationDays:
		return m.DurationDays()
	case couponfixamount.FieldMessage:
		return m.Message()
	case couponfixamount.FieldName:
		return m.Name()
	case couponfixamount.FieldAllocated:
		return m.Allocated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponFixAmountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case couponfixamount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case couponfixamount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case couponfixamount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case couponfixamount.FieldAppID:
		return m.OldAppID(ctx)
	case couponfixamount.FieldDenomination:
		return m.OldDenomination(ctx)
	case couponfixamount.FieldCirculation:
		return m.OldCirculation(ctx)
	case couponfixamount.FieldReleasedByUserID:
		return m.OldReleasedByUserID(ctx)
	case couponfixamount.FieldStartAt:
		return m.OldStartAt(ctx)
	case couponfixamount.FieldDurationDays:
		return m.OldDurationDays(ctx)
	case couponfixamount.FieldMessage:
		return m.OldMessage(ctx)
	case couponfixamount.FieldName:
		return m.OldName(ctx)
	case couponfixamount.FieldAllocated:
		return m.OldAllocated(ctx)
	}
	return nil, fmt.Errorf("unknown CouponFixAmount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponFixAmountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case couponfixamount.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case couponfixamount.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case couponfixamount.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case couponfixamount.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case couponfixamount.FieldDenomination:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDenomination(v)
		return nil
	case couponfixamount.FieldCirculation:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCirculation(v)
		return nil
	case couponfixamount.FieldReleasedByUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleasedByUserID(v)
		return nil
	case couponfixamount.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case couponfixamount.FieldDurationDays:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationDays(v)
		return nil
	case couponfixamount.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case couponfixamount.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case couponfixamount.FieldAllocated:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocated(v)
		return nil
	}
	return fmt.Errorf("unknown CouponFixAmount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponFixAmountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, couponfixamount.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, couponfixamount.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, couponfixamount.FieldDeletedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, couponfixamount.FieldStartAt)
	}
	if m.addduration_days != nil {
		fields = append(fields, couponfixamount.FieldDurationDays)
	}
	if m.addallocated != nil {
		fields = append(fields, couponfixamount.FieldAllocated)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponFixAmountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case couponfixamount.FieldCreatedAt:
		return m.AddedCreatedAt()
	case couponfixamount.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case couponfixamount.FieldDeletedAt:
		return m.AddedDeletedAt()
	case couponfixamount.FieldStartAt:
		return m.AddedStartAt()
	case couponfixamount.FieldDurationDays:
		return m.AddedDurationDays()
	case couponfixamount.FieldAllocated:
		return m.AddedAllocated()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponFixAmountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case couponfixamount.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case couponfixamount.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case couponfixamount.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case couponfixamount.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case couponfixamount.FieldDurationDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationDays(v)
		return nil
	case couponfixamount.FieldAllocated:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllocated(v)
		return nil
	}
	return fmt.Errorf("unknown CouponFixAmount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponFixAmountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(couponfixamount.FieldDenomination) {
		fields = append(fields, couponfixamount.FieldDenomination)
	}
	if m.FieldCleared(couponfixamount.FieldCirculation) {
		fields = append(fields, couponfixamount.FieldCirculation)
	}
	if m.FieldCleared(couponfixamount.FieldStartAt) {
		fields = append(fields, couponfixamount.FieldStartAt)
	}
	if m.FieldCleared(couponfixamount.FieldDurationDays) {
		fields = append(fields, couponfixamount.FieldDurationDays)
	}
	if m.FieldCleared(couponfixamount.FieldMessage) {
		fields = append(fields, couponfixamount.FieldMessage)
	}
	if m.FieldCleared(couponfixamount.FieldName) {
		fields = append(fields, couponfixamount.FieldName)
	}
	if m.FieldCleared(couponfixamount.FieldAllocated) {
		fields = append(fields, couponfixamount.FieldAllocated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponFixAmountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponFixAmountMutation) ClearField(name string) error {
	switch name {
	case couponfixamount.FieldDenomination:
		m.ClearDenomination()
		return nil
	case couponfixamount.FieldCirculation:
		m.ClearCirculation()
		return nil
	case couponfixamount.FieldStartAt:
		m.ClearStartAt()
		return nil
	case couponfixamount.FieldDurationDays:
		m.ClearDurationDays()
		return nil
	case couponfixamount.FieldMessage:
		m.ClearMessage()
		return nil
	case couponfixamount.FieldName:
		m.ClearName()
		return nil
	case couponfixamount.FieldAllocated:
		m.ClearAllocated()
		return nil
	}
	return fmt.Errorf("unknown CouponFixAmount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponFixAmountMutation) ResetField(name string) error {
	switch name {
	case couponfixamount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case couponfixamount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case couponfixamount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case couponfixamount.FieldAppID:
		m.ResetAppID()
		return nil
	case couponfixamount.FieldDenomination:
		m.ResetDenomination()
		return nil
	case couponfixamount.FieldCirculation:
		m.ResetCirculation()
		return nil
	case couponfixamount.FieldReleasedByUserID:
		m.ResetReleasedByUserID()
		return nil
	case couponfixamount.FieldStartAt:
		m.ResetStartAt()
		return nil
	case couponfixamount.FieldDurationDays:
		m.ResetDurationDays()
		return nil
	case couponfixamount.FieldMessage:
		m.ResetMessage()
		return nil
	case couponfixamount.FieldName:
		m.ResetName()
		return nil
	case couponfixamount.FieldAllocated:
		m.ResetAllocated()
		return nil
	}
	return fmt.Errorf("unknown CouponFixAmount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponFixAmountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponFixAmountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponFixAmountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponFixAmountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponFixAmountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponFixAmountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponFixAmountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CouponFixAmount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponFixAmountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CouponFixAmount edge %s", name)
}

// CouponSpecialOfferMutation represents an operation that mutates the CouponSpecialOffer nodes in the graph.
type CouponSpecialOfferMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *uint32
	addcreated_at       *int32
	updated_at          *uint32
	addupdated_at       *int32
	deleted_at          *uint32
	adddeleted_at       *int32
	app_id              *uuid.UUID
	user_id             *uuid.UUID
	amount              *decimal.Decimal
	released_by_user_id *uuid.UUID
	start_at            *uint32
	addstart_at         *int32
	duration_days       *uint32
	addduration_days    *int32
	message             *string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*CouponSpecialOffer, error)
	predicates          []predicate.CouponSpecialOffer
}

var _ ent.Mutation = (*CouponSpecialOfferMutation)(nil)

// couponspecialofferOption allows management of the mutation configuration using functional options.
type couponspecialofferOption func(*CouponSpecialOfferMutation)

// newCouponSpecialOfferMutation creates new mutation for the CouponSpecialOffer entity.
func newCouponSpecialOfferMutation(c config, op Op, opts ...couponspecialofferOption) *CouponSpecialOfferMutation {
	m := &CouponSpecialOfferMutation{
		config:        c,
		op:            op,
		typ:           TypeCouponSpecialOffer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponSpecialOfferID sets the ID field of the mutation.
func withCouponSpecialOfferID(id uuid.UUID) couponspecialofferOption {
	return func(m *CouponSpecialOfferMutation) {
		var (
			err   error
			once  sync.Once
			value *CouponSpecialOffer
		)
		m.oldValue = func(ctx context.Context) (*CouponSpecialOffer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CouponSpecialOffer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCouponSpecialOffer sets the old CouponSpecialOffer of the mutation.
func withCouponSpecialOffer(node *CouponSpecialOffer) couponspecialofferOption {
	return func(m *CouponSpecialOfferMutation) {
		m.oldValue = func(context.Context) (*CouponSpecialOffer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponSpecialOfferMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponSpecialOfferMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CouponSpecialOffer entities.
func (m *CouponSpecialOfferMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponSpecialOfferMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponSpecialOfferMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CouponSpecialOffer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponSpecialOfferMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponSpecialOfferMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CouponSpecialOffer entity.
// If the CouponSpecialOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponSpecialOfferMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CouponSpecialOfferMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CouponSpecialOfferMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponSpecialOfferMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponSpecialOfferMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponSpecialOfferMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CouponSpecialOffer entity.
// If the CouponSpecialOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponSpecialOfferMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CouponSpecialOfferMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CouponSpecialOfferMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponSpecialOfferMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CouponSpecialOfferMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CouponSpecialOfferMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CouponSpecialOffer entity.
// If the CouponSpecialOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponSpecialOfferMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CouponSpecialOfferMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CouponSpecialOfferMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CouponSpecialOfferMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *CouponSpecialOfferMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CouponSpecialOfferMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the CouponSpecialOffer entity.
// If the CouponSpecialOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponSpecialOfferMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CouponSpecialOfferMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *CouponSpecialOfferMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CouponSpecialOfferMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CouponSpecialOffer entity.
// If the CouponSpecialOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponSpecialOfferMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CouponSpecialOfferMutation) ResetUserID() {
	m.user_id = nil
}

// SetAmount sets the "amount" field.
func (m *CouponSpecialOfferMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *CouponSpecialOfferMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the CouponSpecialOffer entity.
// If the CouponSpecialOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponSpecialOfferMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ClearAmount clears the value of the "amount" field.
func (m *CouponSpecialOfferMutation) ClearAmount() {
	m.amount = nil
	m.clearedFields[couponspecialoffer.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *CouponSpecialOfferMutation) AmountCleared() bool {
	_, ok := m.clearedFields[couponspecialoffer.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *CouponSpecialOfferMutation) ResetAmount() {
	m.amount = nil
	delete(m.clearedFields, couponspecialoffer.FieldAmount)
}

// SetReleasedByUserID sets the "released_by_user_id" field.
func (m *CouponSpecialOfferMutation) SetReleasedByUserID(u uuid.UUID) {
	m.released_by_user_id = &u
}

// ReleasedByUserID returns the value of the "released_by_user_id" field in the mutation.
func (m *CouponSpecialOfferMutation) ReleasedByUserID() (r uuid.UUID, exists bool) {
	v := m.released_by_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReleasedByUserID returns the old "released_by_user_id" field's value of the CouponSpecialOffer entity.
// If the CouponSpecialOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponSpecialOfferMutation) OldReleasedByUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleasedByUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleasedByUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleasedByUserID: %w", err)
	}
	return oldValue.ReleasedByUserID, nil
}

// ResetReleasedByUserID resets all changes to the "released_by_user_id" field.
func (m *CouponSpecialOfferMutation) ResetReleasedByUserID() {
	m.released_by_user_id = nil
}

// SetStartAt sets the "start_at" field.
func (m *CouponSpecialOfferMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *CouponSpecialOfferMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the CouponSpecialOffer entity.
// If the CouponSpecialOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponSpecialOfferMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *CouponSpecialOfferMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *CouponSpecialOfferMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *CouponSpecialOfferMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[couponspecialoffer.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *CouponSpecialOfferMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[couponspecialoffer.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *CouponSpecialOfferMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, couponspecialoffer.FieldStartAt)
}

// SetDurationDays sets the "duration_days" field.
func (m *CouponSpecialOfferMutation) SetDurationDays(u uint32) {
	m.duration_days = &u
	m.addduration_days = nil
}

// DurationDays returns the value of the "duration_days" field in the mutation.
func (m *CouponSpecialOfferMutation) DurationDays() (r uint32, exists bool) {
	v := m.duration_days
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationDays returns the old "duration_days" field's value of the CouponSpecialOffer entity.
// If the CouponSpecialOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponSpecialOfferMutation) OldDurationDays(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationDays: %w", err)
	}
	return oldValue.DurationDays, nil
}

// AddDurationDays adds u to the "duration_days" field.
func (m *CouponSpecialOfferMutation) AddDurationDays(u int32) {
	if m.addduration_days != nil {
		*m.addduration_days += u
	} else {
		m.addduration_days = &u
	}
}

// AddedDurationDays returns the value that was added to the "duration_days" field in this mutation.
func (m *CouponSpecialOfferMutation) AddedDurationDays() (r int32, exists bool) {
	v := m.addduration_days
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationDays clears the value of the "duration_days" field.
func (m *CouponSpecialOfferMutation) ClearDurationDays() {
	m.duration_days = nil
	m.addduration_days = nil
	m.clearedFields[couponspecialoffer.FieldDurationDays] = struct{}{}
}

// DurationDaysCleared returns if the "duration_days" field was cleared in this mutation.
func (m *CouponSpecialOfferMutation) DurationDaysCleared() bool {
	_, ok := m.clearedFields[couponspecialoffer.FieldDurationDays]
	return ok
}

// ResetDurationDays resets all changes to the "duration_days" field.
func (m *CouponSpecialOfferMutation) ResetDurationDays() {
	m.duration_days = nil
	m.addduration_days = nil
	delete(m.clearedFields, couponspecialoffer.FieldDurationDays)
}

// SetMessage sets the "message" field.
func (m *CouponSpecialOfferMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *CouponSpecialOfferMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the CouponSpecialOffer entity.
// If the CouponSpecialOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponSpecialOfferMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *CouponSpecialOfferMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[couponspecialoffer.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *CouponSpecialOfferMutation) MessageCleared() bool {
	_, ok := m.clearedFields[couponspecialoffer.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *CouponSpecialOfferMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, couponspecialoffer.FieldMessage)
}

// Where appends a list predicates to the CouponSpecialOfferMutation builder.
func (m *CouponSpecialOfferMutation) Where(ps ...predicate.CouponSpecialOffer) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CouponSpecialOfferMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CouponSpecialOffer).
func (m *CouponSpecialOfferMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponSpecialOfferMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, couponspecialoffer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, couponspecialoffer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, couponspecialoffer.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, couponspecialoffer.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, couponspecialoffer.FieldUserID)
	}
	if m.amount != nil {
		fields = append(fields, couponspecialoffer.FieldAmount)
	}
	if m.released_by_user_id != nil {
		fields = append(fields, couponspecialoffer.FieldReleasedByUserID)
	}
	if m.start_at != nil {
		fields = append(fields, couponspecialoffer.FieldStartAt)
	}
	if m.duration_days != nil {
		fields = append(fields, couponspecialoffer.FieldDurationDays)
	}
	if m.message != nil {
		fields = append(fields, couponspecialoffer.FieldMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponSpecialOfferMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case couponspecialoffer.FieldCreatedAt:
		return m.CreatedAt()
	case couponspecialoffer.FieldUpdatedAt:
		return m.UpdatedAt()
	case couponspecialoffer.FieldDeletedAt:
		return m.DeletedAt()
	case couponspecialoffer.FieldAppID:
		return m.AppID()
	case couponspecialoffer.FieldUserID:
		return m.UserID()
	case couponspecialoffer.FieldAmount:
		return m.Amount()
	case couponspecialoffer.FieldReleasedByUserID:
		return m.ReleasedByUserID()
	case couponspecialoffer.FieldStartAt:
		return m.StartAt()
	case couponspecialoffer.FieldDurationDays:
		return m.DurationDays()
	case couponspecialoffer.FieldMessage:
		return m.Message()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponSpecialOfferMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case couponspecialoffer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case couponspecialoffer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case couponspecialoffer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case couponspecialoffer.FieldAppID:
		return m.OldAppID(ctx)
	case couponspecialoffer.FieldUserID:
		return m.OldUserID(ctx)
	case couponspecialoffer.FieldAmount:
		return m.OldAmount(ctx)
	case couponspecialoffer.FieldReleasedByUserID:
		return m.OldReleasedByUserID(ctx)
	case couponspecialoffer.FieldStartAt:
		return m.OldStartAt(ctx)
	case couponspecialoffer.FieldDurationDays:
		return m.OldDurationDays(ctx)
	case couponspecialoffer.FieldMessage:
		return m.OldMessage(ctx)
	}
	return nil, fmt.Errorf("unknown CouponSpecialOffer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponSpecialOfferMutation) SetField(name string, value ent.Value) error {
	switch name {
	case couponspecialoffer.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case couponspecialoffer.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case couponspecialoffer.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case couponspecialoffer.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case couponspecialoffer.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case couponspecialoffer.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case couponspecialoffer.FieldReleasedByUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleasedByUserID(v)
		return nil
	case couponspecialoffer.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case couponspecialoffer.FieldDurationDays:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationDays(v)
		return nil
	case couponspecialoffer.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	}
	return fmt.Errorf("unknown CouponSpecialOffer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponSpecialOfferMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, couponspecialoffer.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, couponspecialoffer.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, couponspecialoffer.FieldDeletedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, couponspecialoffer.FieldStartAt)
	}
	if m.addduration_days != nil {
		fields = append(fields, couponspecialoffer.FieldDurationDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponSpecialOfferMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case couponspecialoffer.FieldCreatedAt:
		return m.AddedCreatedAt()
	case couponspecialoffer.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case couponspecialoffer.FieldDeletedAt:
		return m.AddedDeletedAt()
	case couponspecialoffer.FieldStartAt:
		return m.AddedStartAt()
	case couponspecialoffer.FieldDurationDays:
		return m.AddedDurationDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponSpecialOfferMutation) AddField(name string, value ent.Value) error {
	switch name {
	case couponspecialoffer.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case couponspecialoffer.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case couponspecialoffer.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case couponspecialoffer.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case couponspecialoffer.FieldDurationDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationDays(v)
		return nil
	}
	return fmt.Errorf("unknown CouponSpecialOffer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponSpecialOfferMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(couponspecialoffer.FieldAmount) {
		fields = append(fields, couponspecialoffer.FieldAmount)
	}
	if m.FieldCleared(couponspecialoffer.FieldStartAt) {
		fields = append(fields, couponspecialoffer.FieldStartAt)
	}
	if m.FieldCleared(couponspecialoffer.FieldDurationDays) {
		fields = append(fields, couponspecialoffer.FieldDurationDays)
	}
	if m.FieldCleared(couponspecialoffer.FieldMessage) {
		fields = append(fields, couponspecialoffer.FieldMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponSpecialOfferMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponSpecialOfferMutation) ClearField(name string) error {
	switch name {
	case couponspecialoffer.FieldAmount:
		m.ClearAmount()
		return nil
	case couponspecialoffer.FieldStartAt:
		m.ClearStartAt()
		return nil
	case couponspecialoffer.FieldDurationDays:
		m.ClearDurationDays()
		return nil
	case couponspecialoffer.FieldMessage:
		m.ClearMessage()
		return nil
	}
	return fmt.Errorf("unknown CouponSpecialOffer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponSpecialOfferMutation) ResetField(name string) error {
	switch name {
	case couponspecialoffer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case couponspecialoffer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case couponspecialoffer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case couponspecialoffer.FieldAppID:
		m.ResetAppID()
		return nil
	case couponspecialoffer.FieldUserID:
		m.ResetUserID()
		return nil
	case couponspecialoffer.FieldAmount:
		m.ResetAmount()
		return nil
	case couponspecialoffer.FieldReleasedByUserID:
		m.ResetReleasedByUserID()
		return nil
	case couponspecialoffer.FieldStartAt:
		m.ResetStartAt()
		return nil
	case couponspecialoffer.FieldDurationDays:
		m.ResetDurationDays()
		return nil
	case couponspecialoffer.FieldMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown CouponSpecialOffer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponSpecialOfferMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponSpecialOfferMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponSpecialOfferMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponSpecialOfferMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponSpecialOfferMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponSpecialOfferMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponSpecialOfferMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CouponSpecialOffer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponSpecialOfferMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CouponSpecialOffer edge %s", name)
}

// GoodOrderPercentMutation represents an operation that mutates the GoodOrderPercent nodes in the graph.
type GoodOrderPercentMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	good_id       *uuid.UUID
	percent       *decimal.Decimal
	start_at      *uint32
	addstart_at   *int32
	end_at        *uint32
	addend_at     *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GoodOrderPercent, error)
	predicates    []predicate.GoodOrderPercent
}

var _ ent.Mutation = (*GoodOrderPercentMutation)(nil)

// goodorderpercentOption allows management of the mutation configuration using functional options.
type goodorderpercentOption func(*GoodOrderPercentMutation)

// newGoodOrderPercentMutation creates new mutation for the GoodOrderPercent entity.
func newGoodOrderPercentMutation(c config, op Op, opts ...goodorderpercentOption) *GoodOrderPercentMutation {
	m := &GoodOrderPercentMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodOrderPercent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodOrderPercentID sets the ID field of the mutation.
func withGoodOrderPercentID(id uuid.UUID) goodorderpercentOption {
	return func(m *GoodOrderPercentMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodOrderPercent
		)
		m.oldValue = func(ctx context.Context) (*GoodOrderPercent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodOrderPercent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodOrderPercent sets the old GoodOrderPercent of the mutation.
func withGoodOrderPercent(node *GoodOrderPercent) goodorderpercentOption {
	return func(m *GoodOrderPercentMutation) {
		m.oldValue = func(context.Context) (*GoodOrderPercent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodOrderPercentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodOrderPercentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodOrderPercent entities.
func (m *GoodOrderPercentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodOrderPercentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodOrderPercentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodOrderPercent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodOrderPercentMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodOrderPercentMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodOrderPercent entity.
// If the GoodOrderPercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderPercentMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodOrderPercentMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodOrderPercentMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodOrderPercentMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodOrderPercentMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodOrderPercentMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodOrderPercent entity.
// If the GoodOrderPercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderPercentMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodOrderPercentMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodOrderPercentMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodOrderPercentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodOrderPercentMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodOrderPercentMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodOrderPercent entity.
// If the GoodOrderPercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderPercentMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodOrderPercentMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodOrderPercentMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodOrderPercentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *GoodOrderPercentMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *GoodOrderPercentMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the GoodOrderPercent entity.
// If the GoodOrderPercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderPercentMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *GoodOrderPercentMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[goodorderpercent.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *GoodOrderPercentMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[goodorderpercent.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *GoodOrderPercentMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, goodorderpercent.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *GoodOrderPercentMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *GoodOrderPercentMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the GoodOrderPercent entity.
// If the GoodOrderPercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderPercentMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *GoodOrderPercentMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[goodorderpercent.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *GoodOrderPercentMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[goodorderpercent.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *GoodOrderPercentMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, goodorderpercent.FieldUserID)
}

// SetGoodID sets the "good_id" field.
func (m *GoodOrderPercentMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *GoodOrderPercentMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the GoodOrderPercent entity.
// If the GoodOrderPercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderPercentMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *GoodOrderPercentMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[goodorderpercent.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *GoodOrderPercentMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[goodorderpercent.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *GoodOrderPercentMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, goodorderpercent.FieldGoodID)
}

// SetPercent sets the "percent" field.
func (m *GoodOrderPercentMutation) SetPercent(d decimal.Decimal) {
	m.percent = &d
}

// Percent returns the value of the "percent" field in the mutation.
func (m *GoodOrderPercentMutation) Percent() (r decimal.Decimal, exists bool) {
	v := m.percent
	if v == nil {
		return
	}
	return *v, true
}

// OldPercent returns the old "percent" field's value of the GoodOrderPercent entity.
// If the GoodOrderPercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderPercentMutation) OldPercent(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPercent: %w", err)
	}
	return oldValue.Percent, nil
}

// ClearPercent clears the value of the "percent" field.
func (m *GoodOrderPercentMutation) ClearPercent() {
	m.percent = nil
	m.clearedFields[goodorderpercent.FieldPercent] = struct{}{}
}

// PercentCleared returns if the "percent" field was cleared in this mutation.
func (m *GoodOrderPercentMutation) PercentCleared() bool {
	_, ok := m.clearedFields[goodorderpercent.FieldPercent]
	return ok
}

// ResetPercent resets all changes to the "percent" field.
func (m *GoodOrderPercentMutation) ResetPercent() {
	m.percent = nil
	delete(m.clearedFields, goodorderpercent.FieldPercent)
}

// SetStartAt sets the "start_at" field.
func (m *GoodOrderPercentMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *GoodOrderPercentMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the GoodOrderPercent entity.
// If the GoodOrderPercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderPercentMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *GoodOrderPercentMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *GoodOrderPercentMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *GoodOrderPercentMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[goodorderpercent.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *GoodOrderPercentMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[goodorderpercent.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *GoodOrderPercentMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, goodorderpercent.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *GoodOrderPercentMutation) SetEndAt(u uint32) {
	m.end_at = &u
	m.addend_at = nil
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *GoodOrderPercentMutation) EndAt() (r uint32, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the GoodOrderPercent entity.
// If the GoodOrderPercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderPercentMutation) OldEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// AddEndAt adds u to the "end_at" field.
func (m *GoodOrderPercentMutation) AddEndAt(u int32) {
	if m.addend_at != nil {
		*m.addend_at += u
	} else {
		m.addend_at = &u
	}
}

// AddedEndAt returns the value that was added to the "end_at" field in this mutation.
func (m *GoodOrderPercentMutation) AddedEndAt() (r int32, exists bool) {
	v := m.addend_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndAt clears the value of the "end_at" field.
func (m *GoodOrderPercentMutation) ClearEndAt() {
	m.end_at = nil
	m.addend_at = nil
	m.clearedFields[goodorderpercent.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *GoodOrderPercentMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[goodorderpercent.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *GoodOrderPercentMutation) ResetEndAt() {
	m.end_at = nil
	m.addend_at = nil
	delete(m.clearedFields, goodorderpercent.FieldEndAt)
}

// Where appends a list predicates to the GoodOrderPercentMutation builder.
func (m *GoodOrderPercentMutation) Where(ps ...predicate.GoodOrderPercent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodOrderPercentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodOrderPercent).
func (m *GoodOrderPercentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodOrderPercentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, goodorderpercent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodorderpercent.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodorderpercent.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, goodorderpercent.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, goodorderpercent.FieldUserID)
	}
	if m.good_id != nil {
		fields = append(fields, goodorderpercent.FieldGoodID)
	}
	if m.percent != nil {
		fields = append(fields, goodorderpercent.FieldPercent)
	}
	if m.start_at != nil {
		fields = append(fields, goodorderpercent.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, goodorderpercent.FieldEndAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodOrderPercentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodorderpercent.FieldCreatedAt:
		return m.CreatedAt()
	case goodorderpercent.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodorderpercent.FieldDeletedAt:
		return m.DeletedAt()
	case goodorderpercent.FieldAppID:
		return m.AppID()
	case goodorderpercent.FieldUserID:
		return m.UserID()
	case goodorderpercent.FieldGoodID:
		return m.GoodID()
	case goodorderpercent.FieldPercent:
		return m.Percent()
	case goodorderpercent.FieldStartAt:
		return m.StartAt()
	case goodorderpercent.FieldEndAt:
		return m.EndAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodOrderPercentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodorderpercent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodorderpercent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodorderpercent.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodorderpercent.FieldAppID:
		return m.OldAppID(ctx)
	case goodorderpercent.FieldUserID:
		return m.OldUserID(ctx)
	case goodorderpercent.FieldGoodID:
		return m.OldGoodID(ctx)
	case goodorderpercent.FieldPercent:
		return m.OldPercent(ctx)
	case goodorderpercent.FieldStartAt:
		return m.OldStartAt(ctx)
	case goodorderpercent.FieldEndAt:
		return m.OldEndAt(ctx)
	}
	return nil, fmt.Errorf("unknown GoodOrderPercent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodOrderPercentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodorderpercent.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodorderpercent.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodorderpercent.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodorderpercent.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case goodorderpercent.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case goodorderpercent.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case goodorderpercent.FieldPercent:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPercent(v)
		return nil
	case goodorderpercent.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case goodorderpercent.FieldEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoodOrderPercent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodOrderPercentMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodorderpercent.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodorderpercent.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodorderpercent.FieldDeletedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, goodorderpercent.FieldStartAt)
	}
	if m.addend_at != nil {
		fields = append(fields, goodorderpercent.FieldEndAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodOrderPercentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodorderpercent.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodorderpercent.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodorderpercent.FieldDeletedAt:
		return m.AddedDeletedAt()
	case goodorderpercent.FieldStartAt:
		return m.AddedStartAt()
	case goodorderpercent.FieldEndAt:
		return m.AddedEndAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodOrderPercentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodorderpercent.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodorderpercent.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodorderpercent.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case goodorderpercent.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case goodorderpercent.FieldEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoodOrderPercent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodOrderPercentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodorderpercent.FieldAppID) {
		fields = append(fields, goodorderpercent.FieldAppID)
	}
	if m.FieldCleared(goodorderpercent.FieldUserID) {
		fields = append(fields, goodorderpercent.FieldUserID)
	}
	if m.FieldCleared(goodorderpercent.FieldGoodID) {
		fields = append(fields, goodorderpercent.FieldGoodID)
	}
	if m.FieldCleared(goodorderpercent.FieldPercent) {
		fields = append(fields, goodorderpercent.FieldPercent)
	}
	if m.FieldCleared(goodorderpercent.FieldStartAt) {
		fields = append(fields, goodorderpercent.FieldStartAt)
	}
	if m.FieldCleared(goodorderpercent.FieldEndAt) {
		fields = append(fields, goodorderpercent.FieldEndAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodOrderPercentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodOrderPercentMutation) ClearField(name string) error {
	switch name {
	case goodorderpercent.FieldAppID:
		m.ClearAppID()
		return nil
	case goodorderpercent.FieldUserID:
		m.ClearUserID()
		return nil
	case goodorderpercent.FieldGoodID:
		m.ClearGoodID()
		return nil
	case goodorderpercent.FieldPercent:
		m.ClearPercent()
		return nil
	case goodorderpercent.FieldStartAt:
		m.ClearStartAt()
		return nil
	case goodorderpercent.FieldEndAt:
		m.ClearEndAt()
		return nil
	}
	return fmt.Errorf("unknown GoodOrderPercent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodOrderPercentMutation) ResetField(name string) error {
	switch name {
	case goodorderpercent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodorderpercent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodorderpercent.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodorderpercent.FieldAppID:
		m.ResetAppID()
		return nil
	case goodorderpercent.FieldUserID:
		m.ResetUserID()
		return nil
	case goodorderpercent.FieldGoodID:
		m.ResetGoodID()
		return nil
	case goodorderpercent.FieldPercent:
		m.ResetPercent()
		return nil
	case goodorderpercent.FieldStartAt:
		m.ResetStartAt()
		return nil
	case goodorderpercent.FieldEndAt:
		m.ResetEndAt()
		return nil
	}
	return fmt.Errorf("unknown GoodOrderPercent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodOrderPercentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodOrderPercentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodOrderPercentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodOrderPercentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodOrderPercentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodOrderPercentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodOrderPercentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodOrderPercent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodOrderPercentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodOrderPercent edge %s", name)
}

// GoodOrderValuePercentMutation represents an operation that mutates the GoodOrderValuePercent nodes in the graph.
type GoodOrderValuePercentMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	good_id       *uuid.UUID
	percent       *decimal.Decimal
	start_at      *uint32
	addstart_at   *int32
	end_at        *uint32
	addend_at     *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GoodOrderValuePercent, error)
	predicates    []predicate.GoodOrderValuePercent
}

var _ ent.Mutation = (*GoodOrderValuePercentMutation)(nil)

// goodordervaluepercentOption allows management of the mutation configuration using functional options.
type goodordervaluepercentOption func(*GoodOrderValuePercentMutation)

// newGoodOrderValuePercentMutation creates new mutation for the GoodOrderValuePercent entity.
func newGoodOrderValuePercentMutation(c config, op Op, opts ...goodordervaluepercentOption) *GoodOrderValuePercentMutation {
	m := &GoodOrderValuePercentMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodOrderValuePercent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodOrderValuePercentID sets the ID field of the mutation.
func withGoodOrderValuePercentID(id uuid.UUID) goodordervaluepercentOption {
	return func(m *GoodOrderValuePercentMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodOrderValuePercent
		)
		m.oldValue = func(ctx context.Context) (*GoodOrderValuePercent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodOrderValuePercent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodOrderValuePercent sets the old GoodOrderValuePercent of the mutation.
func withGoodOrderValuePercent(node *GoodOrderValuePercent) goodordervaluepercentOption {
	return func(m *GoodOrderValuePercentMutation) {
		m.oldValue = func(context.Context) (*GoodOrderValuePercent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodOrderValuePercentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodOrderValuePercentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodOrderValuePercent entities.
func (m *GoodOrderValuePercentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodOrderValuePercentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodOrderValuePercentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodOrderValuePercent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodOrderValuePercentMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodOrderValuePercentMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodOrderValuePercent entity.
// If the GoodOrderValuePercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderValuePercentMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodOrderValuePercentMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodOrderValuePercentMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodOrderValuePercentMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodOrderValuePercentMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodOrderValuePercentMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodOrderValuePercent entity.
// If the GoodOrderValuePercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderValuePercentMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodOrderValuePercentMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodOrderValuePercentMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodOrderValuePercentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodOrderValuePercentMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodOrderValuePercentMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodOrderValuePercent entity.
// If the GoodOrderValuePercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderValuePercentMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodOrderValuePercentMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodOrderValuePercentMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodOrderValuePercentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *GoodOrderValuePercentMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *GoodOrderValuePercentMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the GoodOrderValuePercent entity.
// If the GoodOrderValuePercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderValuePercentMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *GoodOrderValuePercentMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[goodordervaluepercent.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *GoodOrderValuePercentMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[goodordervaluepercent.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *GoodOrderValuePercentMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, goodordervaluepercent.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *GoodOrderValuePercentMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *GoodOrderValuePercentMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the GoodOrderValuePercent entity.
// If the GoodOrderValuePercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderValuePercentMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *GoodOrderValuePercentMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[goodordervaluepercent.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *GoodOrderValuePercentMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[goodordervaluepercent.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *GoodOrderValuePercentMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, goodordervaluepercent.FieldUserID)
}

// SetGoodID sets the "good_id" field.
func (m *GoodOrderValuePercentMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *GoodOrderValuePercentMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the GoodOrderValuePercent entity.
// If the GoodOrderValuePercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderValuePercentMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *GoodOrderValuePercentMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[goodordervaluepercent.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *GoodOrderValuePercentMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[goodordervaluepercent.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *GoodOrderValuePercentMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, goodordervaluepercent.FieldGoodID)
}

// SetPercent sets the "percent" field.
func (m *GoodOrderValuePercentMutation) SetPercent(d decimal.Decimal) {
	m.percent = &d
}

// Percent returns the value of the "percent" field in the mutation.
func (m *GoodOrderValuePercentMutation) Percent() (r decimal.Decimal, exists bool) {
	v := m.percent
	if v == nil {
		return
	}
	return *v, true
}

// OldPercent returns the old "percent" field's value of the GoodOrderValuePercent entity.
// If the GoodOrderValuePercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderValuePercentMutation) OldPercent(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPercent: %w", err)
	}
	return oldValue.Percent, nil
}

// ClearPercent clears the value of the "percent" field.
func (m *GoodOrderValuePercentMutation) ClearPercent() {
	m.percent = nil
	m.clearedFields[goodordervaluepercent.FieldPercent] = struct{}{}
}

// PercentCleared returns if the "percent" field was cleared in this mutation.
func (m *GoodOrderValuePercentMutation) PercentCleared() bool {
	_, ok := m.clearedFields[goodordervaluepercent.FieldPercent]
	return ok
}

// ResetPercent resets all changes to the "percent" field.
func (m *GoodOrderValuePercentMutation) ResetPercent() {
	m.percent = nil
	delete(m.clearedFields, goodordervaluepercent.FieldPercent)
}

// SetStartAt sets the "start_at" field.
func (m *GoodOrderValuePercentMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *GoodOrderValuePercentMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the GoodOrderValuePercent entity.
// If the GoodOrderValuePercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderValuePercentMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *GoodOrderValuePercentMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *GoodOrderValuePercentMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *GoodOrderValuePercentMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[goodordervaluepercent.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *GoodOrderValuePercentMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[goodordervaluepercent.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *GoodOrderValuePercentMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, goodordervaluepercent.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *GoodOrderValuePercentMutation) SetEndAt(u uint32) {
	m.end_at = &u
	m.addend_at = nil
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *GoodOrderValuePercentMutation) EndAt() (r uint32, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the GoodOrderValuePercent entity.
// If the GoodOrderValuePercent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodOrderValuePercentMutation) OldEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// AddEndAt adds u to the "end_at" field.
func (m *GoodOrderValuePercentMutation) AddEndAt(u int32) {
	if m.addend_at != nil {
		*m.addend_at += u
	} else {
		m.addend_at = &u
	}
}

// AddedEndAt returns the value that was added to the "end_at" field in this mutation.
func (m *GoodOrderValuePercentMutation) AddedEndAt() (r int32, exists bool) {
	v := m.addend_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndAt clears the value of the "end_at" field.
func (m *GoodOrderValuePercentMutation) ClearEndAt() {
	m.end_at = nil
	m.addend_at = nil
	m.clearedFields[goodordervaluepercent.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *GoodOrderValuePercentMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[goodordervaluepercent.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *GoodOrderValuePercentMutation) ResetEndAt() {
	m.end_at = nil
	m.addend_at = nil
	delete(m.clearedFields, goodordervaluepercent.FieldEndAt)
}

// Where appends a list predicates to the GoodOrderValuePercentMutation builder.
func (m *GoodOrderValuePercentMutation) Where(ps ...predicate.GoodOrderValuePercent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodOrderValuePercentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodOrderValuePercent).
func (m *GoodOrderValuePercentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodOrderValuePercentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, goodordervaluepercent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodordervaluepercent.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodordervaluepercent.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, goodordervaluepercent.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, goodordervaluepercent.FieldUserID)
	}
	if m.good_id != nil {
		fields = append(fields, goodordervaluepercent.FieldGoodID)
	}
	if m.percent != nil {
		fields = append(fields, goodordervaluepercent.FieldPercent)
	}
	if m.start_at != nil {
		fields = append(fields, goodordervaluepercent.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, goodordervaluepercent.FieldEndAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodOrderValuePercentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodordervaluepercent.FieldCreatedAt:
		return m.CreatedAt()
	case goodordervaluepercent.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodordervaluepercent.FieldDeletedAt:
		return m.DeletedAt()
	case goodordervaluepercent.FieldAppID:
		return m.AppID()
	case goodordervaluepercent.FieldUserID:
		return m.UserID()
	case goodordervaluepercent.FieldGoodID:
		return m.GoodID()
	case goodordervaluepercent.FieldPercent:
		return m.Percent()
	case goodordervaluepercent.FieldStartAt:
		return m.StartAt()
	case goodordervaluepercent.FieldEndAt:
		return m.EndAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodOrderValuePercentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodordervaluepercent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodordervaluepercent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodordervaluepercent.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodordervaluepercent.FieldAppID:
		return m.OldAppID(ctx)
	case goodordervaluepercent.FieldUserID:
		return m.OldUserID(ctx)
	case goodordervaluepercent.FieldGoodID:
		return m.OldGoodID(ctx)
	case goodordervaluepercent.FieldPercent:
		return m.OldPercent(ctx)
	case goodordervaluepercent.FieldStartAt:
		return m.OldStartAt(ctx)
	case goodordervaluepercent.FieldEndAt:
		return m.OldEndAt(ctx)
	}
	return nil, fmt.Errorf("unknown GoodOrderValuePercent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodOrderValuePercentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodordervaluepercent.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodordervaluepercent.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodordervaluepercent.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodordervaluepercent.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case goodordervaluepercent.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case goodordervaluepercent.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case goodordervaluepercent.FieldPercent:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPercent(v)
		return nil
	case goodordervaluepercent.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case goodordervaluepercent.FieldEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoodOrderValuePercent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodOrderValuePercentMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodordervaluepercent.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodordervaluepercent.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodordervaluepercent.FieldDeletedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, goodordervaluepercent.FieldStartAt)
	}
	if m.addend_at != nil {
		fields = append(fields, goodordervaluepercent.FieldEndAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodOrderValuePercentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodordervaluepercent.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodordervaluepercent.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodordervaluepercent.FieldDeletedAt:
		return m.AddedDeletedAt()
	case goodordervaluepercent.FieldStartAt:
		return m.AddedStartAt()
	case goodordervaluepercent.FieldEndAt:
		return m.AddedEndAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodOrderValuePercentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodordervaluepercent.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodordervaluepercent.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodordervaluepercent.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case goodordervaluepercent.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case goodordervaluepercent.FieldEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoodOrderValuePercent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodOrderValuePercentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodordervaluepercent.FieldAppID) {
		fields = append(fields, goodordervaluepercent.FieldAppID)
	}
	if m.FieldCleared(goodordervaluepercent.FieldUserID) {
		fields = append(fields, goodordervaluepercent.FieldUserID)
	}
	if m.FieldCleared(goodordervaluepercent.FieldGoodID) {
		fields = append(fields, goodordervaluepercent.FieldGoodID)
	}
	if m.FieldCleared(goodordervaluepercent.FieldPercent) {
		fields = append(fields, goodordervaluepercent.FieldPercent)
	}
	if m.FieldCleared(goodordervaluepercent.FieldStartAt) {
		fields = append(fields, goodordervaluepercent.FieldStartAt)
	}
	if m.FieldCleared(goodordervaluepercent.FieldEndAt) {
		fields = append(fields, goodordervaluepercent.FieldEndAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodOrderValuePercentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodOrderValuePercentMutation) ClearField(name string) error {
	switch name {
	case goodordervaluepercent.FieldAppID:
		m.ClearAppID()
		return nil
	case goodordervaluepercent.FieldUserID:
		m.ClearUserID()
		return nil
	case goodordervaluepercent.FieldGoodID:
		m.ClearGoodID()
		return nil
	case goodordervaluepercent.FieldPercent:
		m.ClearPercent()
		return nil
	case goodordervaluepercent.FieldStartAt:
		m.ClearStartAt()
		return nil
	case goodordervaluepercent.FieldEndAt:
		m.ClearEndAt()
		return nil
	}
	return fmt.Errorf("unknown GoodOrderValuePercent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodOrderValuePercentMutation) ResetField(name string) error {
	switch name {
	case goodordervaluepercent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodordervaluepercent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodordervaluepercent.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodordervaluepercent.FieldAppID:
		m.ResetAppID()
		return nil
	case goodordervaluepercent.FieldUserID:
		m.ResetUserID()
		return nil
	case goodordervaluepercent.FieldGoodID:
		m.ResetGoodID()
		return nil
	case goodordervaluepercent.FieldPercent:
		m.ResetPercent()
		return nil
	case goodordervaluepercent.FieldStartAt:
		m.ResetStartAt()
		return nil
	case goodordervaluepercent.FieldEndAt:
		m.ResetEndAt()
		return nil
	}
	return fmt.Errorf("unknown GoodOrderValuePercent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodOrderValuePercentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodOrderValuePercentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodOrderValuePercentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodOrderValuePercentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodOrderValuePercentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodOrderValuePercentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodOrderValuePercentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodOrderValuePercent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodOrderValuePercentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodOrderValuePercent edge %s", name)
}

// InvitationCodeMutation represents an operation that mutates the InvitationCode nodes in the graph.
type InvitationCodeMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	app_id          *uuid.UUID
	user_id         *uuid.UUID
	invitation_code *string
	disabled        *bool
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*InvitationCode, error)
	predicates      []predicate.InvitationCode
}

var _ ent.Mutation = (*InvitationCodeMutation)(nil)

// invitationcodeOption allows management of the mutation configuration using functional options.
type invitationcodeOption func(*InvitationCodeMutation)

// newInvitationCodeMutation creates new mutation for the InvitationCode entity.
func newInvitationCodeMutation(c config, op Op, opts ...invitationcodeOption) *InvitationCodeMutation {
	m := &InvitationCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitationCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationCodeID sets the ID field of the mutation.
func withInvitationCodeID(id uuid.UUID) invitationcodeOption {
	return func(m *InvitationCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *InvitationCode
		)
		m.oldValue = func(ctx context.Context) (*InvitationCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvitationCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitationCode sets the old InvitationCode of the mutation.
func withInvitationCode(node *InvitationCode) invitationcodeOption {
	return func(m *InvitationCodeMutation) {
		m.oldValue = func(context.Context) (*InvitationCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvitationCode entities.
func (m *InvitationCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvitationCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InvitationCodeMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvitationCodeMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *InvitationCodeMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *InvitationCodeMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvitationCodeMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvitationCodeMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvitationCodeMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *InvitationCodeMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *InvitationCodeMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvitationCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InvitationCodeMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InvitationCodeMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *InvitationCodeMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *InvitationCodeMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InvitationCodeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *InvitationCodeMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *InvitationCodeMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *InvitationCodeMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *InvitationCodeMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InvitationCodeMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InvitationCodeMutation) ResetUserID() {
	m.user_id = nil
}

// SetInvitationCode sets the "invitation_code" field.
func (m *InvitationCodeMutation) SetInvitationCode(s string) {
	m.invitation_code = &s
}

// InvitationCode returns the value of the "invitation_code" field in the mutation.
func (m *InvitationCodeMutation) InvitationCode() (r string, exists bool) {
	v := m.invitation_code
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitationCode returns the old "invitation_code" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldInvitationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitationCode: %w", err)
	}
	return oldValue.InvitationCode, nil
}

// ClearInvitationCode clears the value of the "invitation_code" field.
func (m *InvitationCodeMutation) ClearInvitationCode() {
	m.invitation_code = nil
	m.clearedFields[invitationcode.FieldInvitationCode] = struct{}{}
}

// InvitationCodeCleared returns if the "invitation_code" field was cleared in this mutation.
func (m *InvitationCodeMutation) InvitationCodeCleared() bool {
	_, ok := m.clearedFields[invitationcode.FieldInvitationCode]
	return ok
}

// ResetInvitationCode resets all changes to the "invitation_code" field.
func (m *InvitationCodeMutation) ResetInvitationCode() {
	m.invitation_code = nil
	delete(m.clearedFields, invitationcode.FieldInvitationCode)
}

// SetDisabled sets the "disabled" field.
func (m *InvitationCodeMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *InvitationCodeMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *InvitationCodeMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[invitationcode.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *InvitationCodeMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[invitationcode.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *InvitationCodeMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, invitationcode.FieldDisabled)
}

// Where appends a list predicates to the InvitationCodeMutation builder.
func (m *InvitationCodeMutation) Where(ps ...predicate.InvitationCode) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InvitationCodeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InvitationCode).
func (m *InvitationCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationCodeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, invitationcode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invitationcode.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, invitationcode.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, invitationcode.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, invitationcode.FieldUserID)
	}
	if m.invitation_code != nil {
		fields = append(fields, invitationcode.FieldInvitationCode)
	}
	if m.disabled != nil {
		fields = append(fields, invitationcode.FieldDisabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitationcode.FieldCreatedAt:
		return m.CreatedAt()
	case invitationcode.FieldUpdatedAt:
		return m.UpdatedAt()
	case invitationcode.FieldDeletedAt:
		return m.DeletedAt()
	case invitationcode.FieldAppID:
		return m.AppID()
	case invitationcode.FieldUserID:
		return m.UserID()
	case invitationcode.FieldInvitationCode:
		return m.InvitationCode()
	case invitationcode.FieldDisabled:
		return m.Disabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitationcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invitationcode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invitationcode.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case invitationcode.FieldAppID:
		return m.OldAppID(ctx)
	case invitationcode.FieldUserID:
		return m.OldUserID(ctx)
	case invitationcode.FieldInvitationCode:
		return m.OldInvitationCode(ctx)
	case invitationcode.FieldDisabled:
		return m.OldDisabled(ctx)
	}
	return nil, fmt.Errorf("unknown InvitationCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitationcode.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invitationcode.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invitationcode.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case invitationcode.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case invitationcode.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case invitationcode.FieldInvitationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitationCode(v)
		return nil
	case invitationcode.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown InvitationCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationCodeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, invitationcode.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, invitationcode.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, invitationcode.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invitationcode.FieldCreatedAt:
		return m.AddedCreatedAt()
	case invitationcode.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case invitationcode.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invitationcode.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case invitationcode.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case invitationcode.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InvitationCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invitationcode.FieldInvitationCode) {
		fields = append(fields, invitationcode.FieldInvitationCode)
	}
	if m.FieldCleared(invitationcode.FieldDisabled) {
		fields = append(fields, invitationcode.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationCodeMutation) ClearField(name string) error {
	switch name {
	case invitationcode.FieldInvitationCode:
		m.ClearInvitationCode()
		return nil
	case invitationcode.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown InvitationCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationCodeMutation) ResetField(name string) error {
	switch name {
	case invitationcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invitationcode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invitationcode.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case invitationcode.FieldAppID:
		m.ResetAppID()
		return nil
	case invitationcode.FieldUserID:
		m.ResetUserID()
		return nil
	case invitationcode.FieldInvitationCode:
		m.ResetInvitationCode()
		return nil
	case invitationcode.FieldDisabled:
		m.ResetDisabled()
		return nil
	}
	return fmt.Errorf("unknown InvitationCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationCodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationCodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationCodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InvitationCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationCodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InvitationCode edge %s", name)
}

// RegistrationMutation represents an operation that mutates the Registration nodes in the graph.
type RegistrationMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	inviter_id    *uuid.UUID
	invitee_id    *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Registration, error)
	predicates    []predicate.Registration
}

var _ ent.Mutation = (*RegistrationMutation)(nil)

// registrationOption allows management of the mutation configuration using functional options.
type registrationOption func(*RegistrationMutation)

// newRegistrationMutation creates new mutation for the Registration entity.
func newRegistrationMutation(c config, op Op, opts ...registrationOption) *RegistrationMutation {
	m := &RegistrationMutation{
		config:        c,
		op:            op,
		typ:           TypeRegistration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegistrationID sets the ID field of the mutation.
func withRegistrationID(id uuid.UUID) registrationOption {
	return func(m *RegistrationMutation) {
		var (
			err   error
			once  sync.Once
			value *Registration
		)
		m.oldValue = func(ctx context.Context) (*Registration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Registration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegistration sets the old Registration of the mutation.
func withRegistration(node *Registration) registrationOption {
	return func(m *RegistrationMutation) {
		m.oldValue = func(context.Context) (*Registration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegistrationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegistrationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Registration entities.
func (m *RegistrationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RegistrationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RegistrationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Registration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RegistrationMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RegistrationMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *RegistrationMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RegistrationMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RegistrationMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RegistrationMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RegistrationMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *RegistrationMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RegistrationMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RegistrationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RegistrationMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RegistrationMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *RegistrationMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RegistrationMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RegistrationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *RegistrationMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *RegistrationMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *RegistrationMutation) ResetAppID() {
	m.app_id = nil
}

// SetInviterID sets the "inviter_id" field.
func (m *RegistrationMutation) SetInviterID(u uuid.UUID) {
	m.inviter_id = &u
}

// InviterID returns the value of the "inviter_id" field in the mutation.
func (m *RegistrationMutation) InviterID() (r uuid.UUID, exists bool) {
	v := m.inviter_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInviterID returns the old "inviter_id" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldInviterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviterID: %w", err)
	}
	return oldValue.InviterID, nil
}

// ResetInviterID resets all changes to the "inviter_id" field.
func (m *RegistrationMutation) ResetInviterID() {
	m.inviter_id = nil
}

// SetInviteeID sets the "invitee_id" field.
func (m *RegistrationMutation) SetInviteeID(u uuid.UUID) {
	m.invitee_id = &u
}

// InviteeID returns the value of the "invitee_id" field in the mutation.
func (m *RegistrationMutation) InviteeID() (r uuid.UUID, exists bool) {
	v := m.invitee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteeID returns the old "invitee_id" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldInviteeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteeID: %w", err)
	}
	return oldValue.InviteeID, nil
}

// ResetInviteeID resets all changes to the "invitee_id" field.
func (m *RegistrationMutation) ResetInviteeID() {
	m.invitee_id = nil
}

// Where appends a list predicates to the RegistrationMutation builder.
func (m *RegistrationMutation) Where(ps ...predicate.Registration) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RegistrationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Registration).
func (m *RegistrationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RegistrationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, registration.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, registration.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, registration.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, registration.FieldAppID)
	}
	if m.inviter_id != nil {
		fields = append(fields, registration.FieldInviterID)
	}
	if m.invitee_id != nil {
		fields = append(fields, registration.FieldInviteeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RegistrationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case registration.FieldCreatedAt:
		return m.CreatedAt()
	case registration.FieldUpdatedAt:
		return m.UpdatedAt()
	case registration.FieldDeletedAt:
		return m.DeletedAt()
	case registration.FieldAppID:
		return m.AppID()
	case registration.FieldInviterID:
		return m.InviterID()
	case registration.FieldInviteeID:
		return m.InviteeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RegistrationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case registration.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case registration.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case registration.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case registration.FieldAppID:
		return m.OldAppID(ctx)
	case registration.FieldInviterID:
		return m.OldInviterID(ctx)
	case registration.FieldInviteeID:
		return m.OldInviteeID(ctx)
	}
	return nil, fmt.Errorf("unknown Registration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegistrationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case registration.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case registration.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case registration.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case registration.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case registration.FieldInviterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviterID(v)
		return nil
	case registration.FieldInviteeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteeID(v)
		return nil
	}
	return fmt.Errorf("unknown Registration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RegistrationMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, registration.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, registration.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, registration.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RegistrationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case registration.FieldCreatedAt:
		return m.AddedCreatedAt()
	case registration.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case registration.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegistrationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case registration.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case registration.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case registration.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Registration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RegistrationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RegistrationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegistrationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Registration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RegistrationMutation) ResetField(name string) error {
	switch name {
	case registration.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case registration.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case registration.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case registration.FieldAppID:
		m.ResetAppID()
		return nil
	case registration.FieldInviterID:
		m.ResetInviterID()
		return nil
	case registration.FieldInviteeID:
		m.ResetInviteeID()
		return nil
	}
	return fmt.Errorf("unknown Registration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RegistrationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RegistrationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RegistrationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RegistrationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RegistrationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RegistrationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RegistrationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Registration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RegistrationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Registration edge %s", name)
}
